<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ext_pointer (ocaml_intrinsics.Ocaml_intrinsics.Ext_pointer)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">ocaml_intrinsics</a> &#x00BB; <a href="../index.html">Ocaml_intrinsics</a> &#x00BB; Ext_pointer</nav><header class="odoc-preamble"><h1>Module <code><span>Ocaml_intrinsics.Ext_pointer</span></code></h1><p><code>Ext_pointer</code> uses values of the OCaml type &quot;int&quot; to represent pointers to 2-byte aligned memory blocks allocated outside the OCaml heap.</p><p>The least significant bit of the address of a 2-byte aligned memory block is 0. This bit is used by this library to represent the address as an OCaml int, which prevents the OCaml GC from following pointers to external memory.</p><p>To encode an external pointer as int: set the least significant bit. To decode int into an external pointer: clear the least significant bit. Note that these encode and decode operations are not the same as tagging and untagging operations on OCaml representation of int, which involves shifting.</p><p><code>Ext_pointer</code> allows OCaml code to pass around and manipulate pointers to external memory blocks without using &quot;naked pointers&quot;.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span class="keyword">private</span> int</span></code></div></div><div class="odoc-spec"><div class="spec value external" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Immediate" class="anchored"><a href="#module-Immediate" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Immediate/index.html">Immediate</a></span><span> (<a href="Immediate/argument-1-V/index.html">V</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Int" class="anchored"><a href="#module-Int" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Int/index.html">Int</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Bool" class="anchored"><a href="#module-Bool" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Bool/index.html">Bool</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value external" id="val-load_untagged_int" class="anchored"><a href="#val-load_untagged_int" class="anchor"></a><code><span><span class="keyword">val</span> load_untagged_int : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>load_int t</code> reads untagged int pointed to by <code>t</code> and returns the corresponding tagged int. This should only be used to read a value written by <code>store_untagged_int</code>. Otherwise, if the value has most significant bit set, it will be lost by tagging. To avoid it, use <code>load_unboxed_nativeint</code> and check before converting to int (should not allocate). The native C stub is the same for both.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-store_untagged_int" class="anchored"><a href="#val-store_untagged_int" class="anchor"></a><code><span><span class="keyword">val</span> store_untagged_int : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>store_int t d</code> untags <code>d</code> and stores the result to the memory pointed to by <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-load_unboxed_nativeint" class="anchored"><a href="#val-load_unboxed_nativeint" class="anchor"></a><code><span><span class="keyword">val</span> load_unboxed_nativeint : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> nativeint</span></code></div><div class="spec-doc"><p><code>load_unboxed_nativeint t</code> reads unboxed nativeint pointed to by <code>t</code> and returns the corresponding (boxed) nativeint allocated on the OCaml heap.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-store_unboxed_nativeint" class="anchored"><a href="#val-store_unboxed_nativeint" class="anchor"></a><code><span><span class="keyword">val</span> store_unboxed_nativeint : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>nativeint <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>store_unboxed_nativeint t d</code> stores the unboxed nativeint to the memory pointed to by <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-load_unboxed_int64" class="anchored"><a href="#val-load_unboxed_int64" class="anchor"></a><code><span><span class="keyword">val</span> load_unboxed_int64 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>load_unboxed_int64 t</code> reads unboxed int64 pointed to by <code>t</code> and returns the corresponding (boxed) int64 allocated on the OCaml heap.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-store_unboxed_int64" class="anchored"><a href="#val-store_unboxed_int64" class="anchor"></a><code><span><span class="keyword">val</span> store_unboxed_int64 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>store_unboxed_int64 t d</code> stores the unboxed int64 to the memory pointed to by <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-load_unboxed_int32" class="anchored"><a href="#val-load_unboxed_int32" class="anchor"></a><code><span><span class="keyword">val</span> load_unboxed_int32 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>load_unboxed_int32 t</code> reads unboxed int32 pointed to by <code>t</code> and returns the corresponding (boxed) int32 allocated on the OCaml heap.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-store_unboxed_int32" class="anchored"><a href="#val-store_unboxed_int32" class="anchor"></a><code><span><span class="keyword">val</span> store_unboxed_int32 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>store_unboxed_int32 t d</code> stores the unboxed int32 to the memory pointed to by <code>t</code>.</p></div></div><p>For float operations, the pointer must be aligned at least to the native integer machine width (meaning on 32-bit platforms, a 32-bit-aligned pointer is acceptable even though the width of the float is 64 bits).</p><div class="odoc-spec"><div class="spec value external" id="val-load_unboxed_float" class="anchored"><a href="#val-load_unboxed_float" class="anchor"></a><code><span><span class="keyword">val</span> load_unboxed_float : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>load_unboxed_float t</code> reads the unboxed float pointed to by <code>t</code>. (If the result is not directly passed to another operation expecting an unboxed float, then it will be boxed.)</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-store_unboxed_float" class="anchored"><a href="#val-store_unboxed_float" class="anchor"></a><code><span><span class="keyword">val</span> store_unboxed_float : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>store_unboxed_float t d</code> stores the unboxed float to the memory pointed to by <code>t</code>.</p></div></div></div></body></html>