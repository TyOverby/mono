<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_thread (core_unix.Core_thread)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">core_unix</a> &#x00BB; Core_thread</nav><header class="odoc-preamble"><h1>Module <code><span>Core_thread</span></code></h1><p>Lightweight threads.</p></header><nav class="odoc-toc"><ul><li><a href="#thread-creation-and-termination">Thread creation and termination</a></li><li><a href="#suspending-threads">Suspending threads</a></li><li><a href="#management-of-signals">Management of signals</a></li><li><a href="#non-portable-pthread-extensions">Non-portable pthread extensions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of thread handles.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><h6 id="thread-creation-and-termination"><a href="#thread-creation-and-termination" class="anchor"></a>Thread creation and termination</h6><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span>on_uncaught_exn:<span>[ `Kill_whole_process <span>| `Print_to_stderr</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>Thread.create funct arg</code> creates a new thread of control, in which the function application <code>funct arg</code> is executed concurrently with the other threads of the program. The application of <code>Thread.create</code> returns the handle of the newly created thread.</p><p>The new thread terminates when the application <code>funct arg</code> returns, either normally or by raising an uncaught exception.</p><p>In the latter case, behavior is controlled by <code>on_uncaught_exn</code>. If <code>`Print_to_stderr</code> is selected, the exception is printed on standard error, but not propagated back to the parent thread. If <code>`Kill_whole_process</code> is selected, the exception is printed to stderr and then the process exits with code 1 (after having run <code>at_exit</code> callbacks, etc.).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-self" class="anchored"><a href="#val-self" class="anchor"></a><code><span><span class="keyword">val</span> self : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Return the thread currently executing.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-id" class="anchored"><a href="#val-id" class="anchor"></a><code><span><span class="keyword">val</span> id : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the identifier of the given thread. A thread identifier is an integer that identifies uniquely the thread. It can be used to build data structures indexed by threads.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exit" class="anchored"><a href="#val-exit" class="anchor"></a><code><span><span class="keyword">val</span> exit : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Terminate prematurely the currently executing thread.</p></div></div><p>This has been deliberately removed from the interface because it is an inherently unsafe operation and is never required.</p><pre><code>(** Terminate prematurely the thread whose handle is given.
    This functionality is available only with bytecode-level threads. *)
val kill : t -&gt; unit</code></pre><h6 id="suspending-threads"><a href="#suspending-threads" class="anchor"></a>Suspending threads</h6><div class="odoc-spec"><div class="spec value" id="val-delay" class="anchored"><a href="#val-delay" class="anchor"></a><code><span><span class="keyword">val</span> delay : <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>delay d</code> suspends the execution of the calling thread for <code>d</code> seconds. The other program threads continue to run during this time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>join th</code> suspends the execution of the calling thread until the thread <code>th</code> has terminated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wait_timed_read" class="anchored"><a href="#val-wait_timed_read" class="anchor"></a><code><span><span class="keyword">val</span> wait_timed_read : <span><a href="../../core_kernel/Caml_unix/index.html#type-file_descr">Caml_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>See <code>Thread</code>.wait_timed_write.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wait_timed_write" class="anchored"><a href="#val-wait_timed_write" class="anchor"></a><code><span><span class="keyword">val</span> wait_timed_write : <span><a href="../../core_kernel/Caml_unix/index.html#type-file_descr">Caml_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <code>Thread</code>.wait_read and <code>Thread</code>.wait_write, but wait for at most the amount of time given as second argument (in seconds). Return <code>true</code> if the file descriptor is ready for input/output and <code>false</code> if the timeout expired.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-yield" class="anchored"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Re-schedule the calling thread without suspending it. This function can be used to give scheduling hints, telling the scheduler that now is a good time to switch to other threads.</p></div></div><h6 id="management-of-signals"><a href="#management-of-signals" class="anchor"></a>Management of signals</h6><p>Signal handling follows the POSIX thread model: signals generated by a thread are delivered to that thread; signals generated externally are delivered to one of the threads that does not block it. Each thread possesses a set of blocked signals, which can be modified using <code>Thread</code>.sigmask. This set is inherited at thread creation time. Per-thread signal masks are supported only by the system thread library under Unix, but not under Win32, nor by the VM thread library.</p><div class="odoc-spec"><div class="spec value" id="val-sigmask" class="anchored"><a href="#val-sigmask" class="anchor"></a><code><span><span class="keyword">val</span> sigmask : 
  <span><a href="../Signal_unix/index.html#type-sigprocmask_command">Signal_unix.sigprocmask_command</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../core/Core/Signal/index.html#type-t">Core.Signal.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../core/Core/Signal/index.html#type-t">Core.Signal.t</a> list</span></span></code></div><div class="spec-doc"><p><code>sigmask cmd sigs</code> changes the set of blocked signals for the calling thread. If <code>cmd</code> is <code>`Set</code>, blocked signals are set to those in the list <code>sigs</code>. If <code>cmd</code> is <code>`Block</code>, the signals in <code>sigs</code> are added to the set of blocked signals. If <code>cmd</code> is <code>`Unblock</code>, the signals in <code>sigs</code> are removed from the set of blocked signals. <code>sigmask</code> returns the set of previously blocked signals for the thread.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wait_signal" class="anchored"><a href="#val-wait_signal" class="anchor"></a><code><span><span class="keyword">val</span> wait_signal : <span><span><a href="../../core/Core/Signal/index.html#type-t">Core.Signal.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>wait_signal sigs</code> suspends the execution of the calling thread until the process receives one of the signals specified in the list <code>sigs</code>. It then returns the number of the signal received. Signal handlers attached to the signals in <code>sigs</code> will not be invoked. The signals <code>sigs</code> are expected to be blocked before calling <code>wait_signal</code>.</p></div></div><p>Jane Street extensions</p><div class="odoc-spec"><div class="spec value" id="val-threads_have_been_created" class="anchored"><a href="#val-threads_have_been_created" class="anchor"></a><code><span><span class="keyword">val</span> threads_have_been_created : <span>unit <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>true</code> iff Thread.create has ever been called, even if there is currently only one running thread.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-num_threads" class="anchored"><a href="#val-num_threads" class="anchor"></a><code><span><span class="keyword">val</span> num_threads : <span>unit <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>num_threads ()</code> attempts to return the number of currently running threads by parsing /proc. Since this is an operation frought with potential failure, we return an option in cases of failure</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_forever" class="anchored"><a href="#val-block_forever" class="anchor"></a><code><span><span class="keyword">val</span> block_forever : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>block_forever ()</code> will block the calling thread forever.</p></div></div><h3 id="non-portable-pthread-extensions"><a href="#non-portable-pthread-extensions" class="anchor"></a>Non-portable pthread extensions</h3><p>The following operations may not be supported on all platforms. Before you can use them, you must first check that they do not contain error values. For example, if you wanted to use <code>setaffinity_self_exn</code> then you would first do:</p><pre><code>let setaffinity_self_exn =
  match Thread.setaffinity_self_exn with
  | Ok f -&gt; f
  | Error err -&gt; (* raise or provide a default implementation. *)</code></pre><p>If your application requires that one of these operations be present then, you could just do this instead:</p><pre><code>let setaffinity_self_exn = Or_error.ok_exn Thread.setaffinity_self_exn</code></pre><div class="odoc-spec"><div class="spec value" id="val-setaffinity_self_exn" class="anchored"><a href="#val-setaffinity_self_exn" class="anchor"></a><code><span><span class="keyword">val</span> setaffinity_self_exn : <span><span>( <span><a href="../../core/Core/Int/Set/index.html#type-t">Core.Int.Set.t</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <a href="../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span></span></code></div><div class="spec-doc"><p>Sets the core affinity of the currently-running thread to the set specified.</p><p>This function is implemented using <code>pthread_setaffinity_np(3)</code>, when available. See the man page for situations when this function may return an error, and therefore raise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getaffinity_self_exn" class="anchored"><a href="#val-getaffinity_self_exn" class="anchor"></a><code><span><span class="keyword">val</span> getaffinity_self_exn : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../../core/Core/Int/Set/index.html#type-t">Core.Int.Set.t</a> )</span> <a href="../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span></span></code></div><div class="spec-doc"><p>Gets the core affinity of the currently-running thread.</p><p>This function is implemented using <code>pthread_getaffinity_np(3)</code>, when available. See the man page for situations when this function may return an error, and therefore raise.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-For_testing" class="anchored"><a href="#module-For_testing" class="anchor"></a><code><span><span class="keyword">module</span> <a href="For_testing/index.html">For_testing</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>