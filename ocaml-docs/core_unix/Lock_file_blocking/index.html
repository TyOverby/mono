<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lock_file_blocking (core_unix.Lock_file_blocking)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">core_unix</a> &#x00BB; Lock_file_blocking</nav><header class="odoc-preamble"><h1>Module <code><span>Lock_file_blocking</span></code></h1><p>Mutual exclusion between processes using flock and lockf. A file is considered locked only if both of these mechanisms work.</p><p>These locks are advisory, meaning that they will not work with systems that don't also try to acquire the matching locks. Although lockf can work across systems (and, in our environment, does work across Linux systems), it is not guaranteed to do so across all implementations.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span>?message:string <span class="arrow">&#45;&gt;</span></span>
  <span>?close_on_exec:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?unlink_on_exit:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>create ?close_on_exec ?message path</code> tries to create a file at <code>path</code> containing the text <code>message</code>, which defaults to the pid of the locking process. It returns true on success, false on failure.</p><p>Note: there is no way to release the lock or the fd created inside! It will only be released when the process dies. If <code>close_on_exec</code> is <code>false</code>, then the lock will not be released until children created via fork and exec also terminate. If not specified, <code>close_on_exec=true</code>.</p><p>Note that by default, the lock file is not cleaned up for you when the process exits. If you pass <code>unlink_on_exit:true</code>, an <code>at_exit</code> handler will be set up to remove the lock file on program termination.</p><p>The lock file is created with mode 664, so will not be world-writable even with umask 0.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_exn" class="anchored"><a href="#val-create_exn" class="anchor"></a><code><span><span class="keyword">val</span> create_exn : 
  <span>?message:string <span class="arrow">&#45;&gt;</span></span>
  <span>?close_on_exec:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?unlink_on_exit:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>create_exn ?message path</code> is like <code>create</code> except that it throws an exception on failure instead of returning a boolean value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-blocking_create" class="anchored"><a href="#val-blocking_create" class="anchor"></a><code><span><span class="keyword">val</span> blocking_create : 
  <span>?timeout:<a href="../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?message:string <span class="arrow">&#45;&gt;</span></span>
  <span>?close_on_exec:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?unlink_on_exit:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>blocking_create t</code> tries to create the lock. If another process holds the lock this function will wait until it is released or until <code>timeout</code> expires.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_locked" class="anchored"><a href="#val-is_locked" class="anchor"></a><code><span><span class="keyword">val</span> is_locked : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_locked path</code> returns <code>true</code> when the file at <code>path</code> exists and is locked, <code>false</code> otherwise. Requires write permission for the lock file.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_pid" class="anchored"><a href="#val-get_pid" class="anchor"></a><code><span><span class="keyword">val</span> get_pid : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../core/Core/Pid/index.html#type-t">Core.Pid.t</a> option</span></span></code></div><div class="spec-doc"><p><code>get_pid path</code> reads the lock file at <code>path</code> and returns the pid in the file. Returns <code>None</code> if the file cannot be read, or if the file contains a message that is not an int.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Nfs" class="anchored"><a href="#module-Nfs" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Nfs/index.html">Nfs</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An implementation-neutral NFS lock file scheme that relies on the atomicity of link over NFS. Rather than relying on a working traditional advisory lock system over NFS, we create a hard link between the file given to the <code>create</code> call and a new file &lt;filename&gt;.nfs_lock. This link call is atomic (in that it succeeds or fails) across all systems that have the same filesystem mounted. The link file must be cleaned up on program exit (normally accomplished by an <code>at_exit</code> handler, but see caveats below).</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Mkdir" class="anchored"><a href="#module-Mkdir" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Mkdir/index.html">Mkdir</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This is the dumbest lock imaginable: we <code>mkdir</code> to lock and <code>rmdir</code> to unlock. This gives you pretty good mutual exclusion, but it makes you vulnerable to stale locks.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Symlink" class="anchored"><a href="#module-Symlink" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Symlink/index.html">Symlink</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This is a bit better than <code>Mkdir</code> and is very likely to be compatible: it lets you atomically write the owner of the lock into the symlink, it's used both by emacs and hg, and it's supposed to work on nfs.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Flock" class="anchored"><a href="#module-Flock" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Flock/index.html">Flock</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This just uses <code>flock</code>. The main reason this module exists is that <code>create</code> won't let you release locks, so we need a new interface.</p></div></div></div></body></html>