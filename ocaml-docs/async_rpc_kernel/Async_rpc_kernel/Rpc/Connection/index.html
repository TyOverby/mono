<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Connection (async_rpc_kernel.Async_rpc_kernel.Rpc.Connection)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">async_rpc_kernel</a> &#x00BB; <a href="../../index.html">Async_rpc_kernel</a> &#x00BB; <a href="../index.html">Rpc</a> &#x00BB; Connection</nav><header class="odoc-preamble"><h1>Module <code><span>Rpc.Connection</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Heartbeat_config" class="anchored"><a href="#module-Heartbeat_config" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Heartbeat_config/index.html">Heartbeat_config</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Client_implementations" class="anchored"><a href="#module-Client_implementations" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Client_implementations/index.html">Client_implementations</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span>?implementations:<span><span class="type-var">'s</span> <span class="xref-unresolved">Async_rpc_kernel__Implementations.t</span></span> <span class="arrow">&#45;&gt;</span></span>
  <span>connection_state:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?handshake_timeout:<a href="../../../../core/Core/Time_ns/Span/index.html#type-t">Core.Time_ns.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?description:<a href="../../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?time_source:<a href="../../../../async_kernel/Async_kernel/Synchronous_time_source/index.html#type-t">Async_kernel.Synchronous_time_source.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Async_rpc_kernel__Transport.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <a href="#type-t">t</a>, <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a> )</span> <a href="../../../../core/Core/Result/index.html#type-t">Core.Result.t</a></span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p>Initiate an Rpc connection on the given transport. <code>implementations</code> should be the bag of implementations that the calling side implements; it defaults to <code>Implementations.null</code> (i.e., &quot;I implement no RPCs&quot;).</p><p><code>connection_state</code> will be called once, before <code>create</code>'s result is determined, on the same connection that <code>create</code> returns. Its output will be provided to the <code>implementations</code> when queries arrive.</p><p>WARNING: If specifying a custom <code>heartbeat_config</code>, make sure that both ends of the Rpc connection use compatible settings for timeout and send frequency. Otherwise, your Rpc connections might close unexpectedly.</p><p><code>description</code> can be used to give some extra information about the connection, which will then show up in error messages and the connection's sexp. If you have lots of connections in your program, this can be useful for distinguishing them.</p><p><code>time_source</code> can be given to define the time_source for which the heartbeating events will be scheduled. Defaults to wall-clock.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-contains_magic_prefix" class="anchored"><a href="#val-contains_magic_prefix" class="anchor"></a><code><span><span class="keyword">val</span> contains_magic_prefix : <span>bool <a href="../../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span></span></code></div><div class="spec-doc"><p>As of Feb 2017, the RPC protocol started to contain a magic number so that one can identify RPC communication. The bool returned by <code>contains_magic_prefix</code> says whether this magic number was observed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-description" class="anchored"><a href="#val-description" class="anchor"></a><code><span><span class="keyword">val</span> description : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../core/Core/Info/index.html#type-t">Core.Info.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-add_heartbeat_callback" class="anchored"><a href="#val-add_heartbeat_callback" class="anchor"></a><code><span><span class="keyword">val</span> add_heartbeat_callback : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>After <code>add_heartbeat_callback t f</code>, <code>f ()</code> will be called after every subsequent heartbeat received by <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reset_heartbeat_timeout" class="anchored"><a href="#val-reset_heartbeat_timeout" class="anchor"></a><code><span><span class="keyword">val</span> reset_heartbeat_timeout : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../core/Core/Time_ns/Span/index.html#type-t">Core.Time_ns.Span.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Changes the heartbeat timeout and restarts the timer by setting <code>last_seen_alive</code> to the current time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-last_seen_alive" class="anchored"><a href="#val-last_seen_alive" class="anchor"></a><code><span><span class="keyword">val</span> last_seen_alive : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../core/Core/Time_ns/index.html#type-t">Core.Time_ns.t</a></span></code></div><div class="spec-doc"><p>The last time either any message has been received or <code>reset_heartbeat_timeout</code> was called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : 
  <span>?streaming_responses_flush_timeout:<a href="../../../../core/Core/Time_ns/Span/index.html#type-t">Core.Time_ns.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?reason:<a href="../../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>close</code> starts closing the connection's transport, and returns a deferred that becomes determined when its close completes. It is ok to call <code>close</code> multiple times on the same <code>t</code>; calls subsequent to the initial call will have no effect, but will return the same deferred as the original call.</p><p>Before closing the underlying transport's writer, <code>close</code> waits for all streaming reponses to be <code>Pipe.upstream_flushed</code> with a timeout of <code>streaming_responses_flush_timeout</code>.</p><p>The <code>reason</code> for closing the connection will be passed to callers of <code>close_reason</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close_finished" class="anchored"><a href="#val-close_finished" class="anchor"></a><code><span><span class="keyword">val</span> close_finished : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>close_finished</code> becomes determined after the close of the connection's transport completes, i.e. the same deferred that <code>close</code> returns. <code>close_finished</code> differs from <code>close</code> in that it does not have the side effect of initiating a close.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close_reason" class="anchored"><a href="#val-close_reason" class="anchor"></a><code><span><span class="keyword">val</span> close_reason : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>on_close:<span>[ `started <span>| `finished</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>close_reason ~on_close t</code> becomes determined when close starts or finishes based on <code>on_close</code>, but additionally returns the reason that the connection was closed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_closed" class="anchored"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> has been called. <code>close</code> may be called internally upon errors or timeouts.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes_to_write" class="anchored"><a href="#val-bytes_to_write" class="anchor"></a><code><span><span class="keyword">val</span> bytes_to_write : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>bytes_to_write</code> and <code>flushed</code> just call the similarly named functions on the <code>Transport.Writer.t</code> within a connection.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flushed" class="anchored"><a href="#val-flushed" class="anchor"></a><code><span><span class="keyword">val</span> flushed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-with_close" class="anchored"><a href="#val-with_close" class="anchor"></a><code><span><span class="keyword">val</span> with_close : 
  <span>?implementations:<span><span class="type-var">'s</span> <span class="xref-unresolved">Async_rpc_kernel__Implementations.t</span></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?handshake_timeout:<a href="../../../../core/Core/Time_ns/Span/index.html#type-t">Core.Time_ns.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?description:<a href="../../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?time_source:<a href="../../../../async_kernel/Async_kernel/Synchronous_time_source/index.html#type-t">Async_kernel.Synchronous_time_source.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>connection_state:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Async_rpc_kernel__Transport.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>dispatch_queries:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>on_handshake_error:
    <span>[ `Raise <span><span>| `Call</span> of <span><a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>with_close</code> tries to create a <code>t</code> using the given transport. If a handshake error is the result, it calls <code>on_handshake_error</code>, for which the default behavior is to raise an exception. If no error results, <code>dispatch_queries</code> is called on <code>t</code>.</p><p>After <code>dispatch_queries</code> returns, if <code>server</code> is None, the <code>t</code> will be closed and the deferred returned by <code>dispatch_queries</code> will be determined immediately. Otherwise, we'll wait until the other side closes the connection and then close <code>t</code> and determine the deferred returned by <code>dispatch_queries</code>.</p><p>When the deferred returned by <code>with_close</code> becomes determined, <code>Transport.close</code> has finished.</p><p>NOTE: Because this connection is closed when the <code>Deferred.t</code> returned by <code>dispatch_queries</code> is determined, you should be careful when using this with <code>Pipe_rpc</code>. For example, simply returning the pipe when you get it will close the pipe immediately. You should instead either use the pipe inside <code>dispatch_queries</code> and not determine its result until you are done with the pipe, or use a different function like <code>create</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-server_with_close" class="anchored"><a href="#val-server_with_close" class="anchor"></a><code><span><span class="keyword">val</span> server_with_close : 
  <span>?handshake_timeout:<a href="../../../../core/Core/Time_ns/Span/index.html#type-t">Core.Time_ns.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?description:<a href="../../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?time_source:<a href="../../../../async_kernel/Async_kernel/Synchronous_time_source/index.html#type-t">Async_kernel.Synchronous_time_source.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Async_rpc_kernel__Transport.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>implementations:<span><span class="type-var">'s</span> <span class="xref-unresolved">Async_rpc_kernel__Implementations.t</span></span> <span class="arrow">&#45;&gt;</span></span>
  <span>connection_state:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>on_handshake_error:
    <span>[ `Raise <span>| `Ignore</span> <span><span>| `Call</span> of <span><a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p>Runs <code>with_close</code> but dispatches no queries. The implementations are required because this function doesn't let you dispatch any queries (i.e., act as a client), it would be pointless to call it if you didn't want to act as a server.</p></div></div></div></body></html>