<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rpc (async_rpc_kernel.Async_rpc_kernel.Rpc)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_rpc_kernel</a> &#x00BB; <a href="../index.html">Async_rpc_kernel</a> &#x00BB; Rpc</nav><header class="odoc-preamble"><h1>Module <code><span>Async_rpc_kernel.Rpc</span></code></h1><p>A library for building asynchronous RPC-style protocols.</p><p>The approach here is to have a separate representation of the server-side implementation of an RPC (An <code>Implementation.t</code>) and the interface that it exports (either an <code>Rpc.t</code>, a <code>State_rpc.t</code> or a <code>Pipe_rpc.t</code>, but we'll refer to them generically as RPC interfaces). A server builds the <code>Implementation.t</code> out of an RPC interface and a function for implementing the RPC, while the client dispatches a request using the same RPC interface.</p><p>The <code>Implementation.t</code> hides the type of the query and the response, whereas the <code>Rpc.t</code> is polymorphic in the query and response type. This allows you to build a <code>Implementations.t</code> out of a list of <code>Implementation.t</code>s.</p><p>Each RPC also comes with a version number. This is meant to allow support of multiple different versions of what is essentially the same RPC. You can think of it as an extension to the name of the RPC, and in fact, each RPC is uniquely identified by its (name, version) pair. RPCs with the same name but different versions should implement similar functionality.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Description" class="anchored"><a href="#module-Description" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Description/index.html">Description</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-On_exception" class="anchored"><a href="#module-On_exception" class="anchor"></a><code><span><span class="keyword">module</span> <a href="On_exception/index.html">On_exception</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>When your implementation raises an exception, that exception might happen before a value is returned or after a value is returned. The latter kind of exception is what the <code>~rest</code> flag to <code>Monitor.try_with</code> is dealing with.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Implementation" class="anchored"><a href="#module-Implementation" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Implementation/index.html">Implementation</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A <code>'connection_state Implementation.t</code> is something that knows how to respond to one query, given a <code>'connection_state</code>. That is, you can create a <code>'connection_state
    Implementation.t</code> by providing a function which takes a query *and* a <code>'connection_state</code> and provides a response.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Implementations" class="anchored"><a href="#module-Implementations" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Implementations/index.html">Implementations</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A <code>'connection_state Implementations.t</code> is something that knows how to respond to many different queries. It is conceptually a package of <code>'connection_state
    Implementation.t</code>s.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Transport" class="anchored"><a href="#module-Transport" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Transport/index.html">Transport</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>RPC transport layer</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Connection" class="anchored"><a href="#module-Connection" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Connection/index.html">Connection</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Rpc" class="anchored"><a href="#module-Rpc" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Rpc/index.html">Rpc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Pipe_close_reason" class="anchored"><a href="#module-Pipe_close_reason" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Pipe_close_reason/index.html">Pipe_close_reason</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Pipe_rpc" class="anchored"><a href="#module-Pipe_rpc" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Pipe_rpc/index.html">Pipe_rpc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-State_rpc" class="anchored"><a href="#module-State_rpc" class="anchor"></a><code><span><span class="keyword">module</span> <a href="State_rpc/index.html">State_rpc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A state rpc is an easy way for two processes to synchronize a data structure by sending updates over the wire. It's basically a pipe rpc that sends/receives an initial state of the data structure, and then updates, and applies the updates under the covers.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-One_way" class="anchored"><a href="#module-One_way" class="anchor"></a><code><span><span class="keyword">module</span> <a href="One_way/index.html">One_way</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An RPC that has no response. Error handling is trickier here than it is for RPCs with responses, as there is no reasonable place to put an error if something goes wrong. Because of this, in the event of an error such as dispatching to an unimplemented RPC, the connection will be shut down. Similarly, if the implementation raises an exception, the connection will be shut down.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Any" class="anchored"><a href="#module-Any" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Any/index.html">Any</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Stable" class="anchored"><a href="#module-Stable" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Stable/index.html">Stable</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>