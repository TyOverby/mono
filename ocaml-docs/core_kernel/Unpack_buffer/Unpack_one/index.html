<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unpack_one (core_kernel.Unpack_buffer.Unpack_one)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">core_kernel</a> &#x00BB; <a href="../index.html">Unpack_buffer</a> &#x00BB; Unpack_one</nav><header class="odoc-preamble"><h1>Module <code><span>Unpack_buffer.Unpack_one</span></code></h1><p>If <code>unpack_one : ('a, 'state) unpack</code>, then <code>unpack_one ~state ~buf ~pos ~len</code> must unpack at most one value of type <code>'a</code> from <code>buf</code> starting at <code>pos</code>, and not using more than <code>len</code> characters. <code>unpack_one</code> must return one the following:</p><ul><li><code>`Ok (value, n)</code> -- unpacking succeeded and consumed <code>n</code> bytes, where <code>0 &lt;= n &lt;=
        len</code>. It is possible to have <code>n = 0</code>, e.g. for sexp unpacking, which can only tell it has reached the end of an atom when it encounters the following punctuation character, which if it is left paren, is the start of the following sexp.</li></ul><ul><li><code>`Not_enough_data (state, n)</code> -- unpacking encountered a valid proper prefix of a packed value, and consumed <code>n</code> bytes, where <code>0 &lt;= n &lt;= len</code>. <code>state</code> can be supplied to a future call to <code>unpack_one</code> to continue unpacking.</li></ul><ul><li><code>`Invalid_data</code> -- unpacking encountered an invalidly packed value.</li></ul><p>A naive <code>unpack_one</code> that only succeeds on a fully packed value could lead to quadratic behavior if a packed value's bytes are input using a linear number of calls to <code>feed</code>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-unpack_result" class="anchored"><a href="#type-unpack_result" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'state) unpack_result</span></span><span> = </span><span>[ </span></code><table><tr id="type-unpack_result.Ok" class="anchored"><td class="def constructor"><a href="#type-unpack_result.Ok" class="anchor"></a><code><span>| </span></code><code><span>`Ok <span class="keyword">of</span> <span class="type-var">'a</span> * int</span></code></td></tr><tr id="type-unpack_result.Not_enough_data" class="anchored"><td class="def constructor"><a href="#type-unpack_result.Not_enough_data" class="anchor"></a><code><span>| </span></code><code><span>`Not_enough_data <span class="keyword">of</span> <span class="type-var">'state</span> * int</span></code></td></tr><tr id="type-unpack_result.Invalid_data" class="anchored"><td class="def constructor"><a href="#type-unpack_result.Invalid_data" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_data <span class="keyword">of</span> <a href="../../../core/Core/Error/index.html#type-t">Core.Error.t</a></span></code></td></tr></table><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-unpack" class="anchored"><a href="#type-unpack" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'state) unpack</span></span><span> =
  <span>state:<span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span>
  <span>buf:<a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>pos:int <span class="arrow">&#45;&gt;</span></span>
  <span>len:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'state</span> )</span> <a href="#type-unpack_result">unpack_result</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = </span></code><table><tr id="type-t.T" class="anchored"><td class="def variant constructor"><a href="#type-t.T" class="anchor"></a><code><span>| </span><span><span class="constructor">T</span> : </span><span>{</span></code><table><tr id="type-t.initial_state" class="anchored"><td class="def record field"><a href="#type-t.initial_state" class="anchor"></a><code><span>initial_state : <span class="type-var">'state</span>;</span></code></td></tr><tr id="type-t.unpack" class="anchored"><td class="def record field"><a href="#type-t.unpack" class="anchor"></a><code><span>unpack : <span><span>( <span class="type-var">'a</span>, <span class="type-var">'state</span> )</span> <a href="#type-unpack">unpack</a></span>;</span></code></td></tr></table><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></td></tr></table></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Monad/module-type-S/index.html">Core.Monad.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../base/Base/Monad/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-include"><div class="odoc-include"><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t &gt;&gt;= f</code> returns a computation that sequences the computations represented by two monad elements. The resulting computation first does <code>t</code> to yield a value <code>v</code>, and then runs the computation returned by <code>f v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t &gt;&gt;| f</code> is <code>t &gt;&gt;= (fun a -&gt; return (f a))</code>.</p></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Monad_infix" class="anchored"><a href="#module-Monad_infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bind t ~f</code> = <code>t &gt;&gt;= f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return v</code> returns the (trivial) computation that returns v.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map t ~f</code> is t &gt;&gt;| f.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join t</code> is <code>t &gt;&gt;= (fun t' -&gt; t')</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ignore_m" class="anchored"><a href="#val-ignore_m" class="anchor"></a><code><span><span class="keyword">val</span> ignore_m : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ignore_m t</code> is <code>map t ~f:(fun _ -&gt; ())</code>. <code>ignore_m</code> used to be called <code>ignore</code>, but we decided that was a bad name, because it shadowed the widely used <code>Caml.ignore</code>. Some monads still do <code>let ignore = ignore_m</code> for historical reasons.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span><span class="keyword">val</span> all_unit : <span><span><span>unit <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Like <code>all</code>, but ensures that every monadic value in the list produces a unit value, all of which are discarded rather than being collected into a list.</p></div></div></div><div class="odoc-include"><div class="odoc-spec"><div class="spec module" id="module-Let_syntax" class="anchored"><a href="#module-Let_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>These are convenient to have in scope when programming with a monad:</p></div></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>initial_state:<span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span>unpack:<span><span>( <span class="type-var">'a</span>, <span class="type-var">'state</span> )</span> <a href="#type-unpack">unpack</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create_bin_prot" class="anchored"><a href="#val-create_bin_prot" class="anchor"></a><code><span><span class="keyword">val</span> create_bin_prot : <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create_bin_prot reader</code> returns an unpacker that reads the &quot;size-prefixed&quot; bin_prot encoding, in which a value is encoded by first writing the length of the bin_prot data as a 64-bit int, and then writing the data itself.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_blob" class="anchored"><a href="#val-bin_blob" class="anchor"></a><code><span><span class="keyword">val</span> bin_blob : <span><a href="../../../bin_prot/Bin_prot/Blob/Opaque/Bigstring/index.html#type-t">Bin_prot.Blob.Opaque.Bigstring.t</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Reads &quot;size-prefixed&quot; bin-blobs, much like <code>create_bin_prot _</code>, but preserves the size information and doesn't deserialize the blob. This allows deserialization to be deferred and the remainder of the sequence can be unpacked if an individual blob can't be deserialized.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp" class="anchored"><a href="#val-sexp" class="anchor"></a><code><span><span class="keyword">val</span> sexp : <span><a href="../../../core/Core/Sexp/index.html#type-t">Core.Sexp.t</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Beware that when unpacking sexps, one cannot tell if one is at the end of an atom until one hits punctuation. So, one should always feed a space (&quot; &quot;) to a sexp unpack buffer after feeding a batch of complete sexps, to ensure that the final sexp is unpacked.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-char" class="anchored"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-Equal" class="anchored"><a href="#module-type-Equal" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Equal/index.html">Equal</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-expect" class="anchored"><a href="#val-expect" class="anchor"></a><code><span><span class="keyword">val</span> expect : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="keyword">module</span> <a href="module-type-Equal/index.html">Equal</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Equal/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>expect t equal a</code> returns an unpacker that unpacks using <code>t</code> and then returns <code>`Ok</code> if the unpacked value equals <code>a</code>, or <code>`Invalid_data</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-expect_char" class="anchored"><a href="#val-expect_char" class="anchor"></a><code><span><span class="keyword">val</span> expect_char : <span>char <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>expect_char</code> is <code>expect char (module Char)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-newline" class="anchored"><a href="#val-newline" class="anchor"></a><code><span><span class="keyword">val</span> newline : <span>unit <a href="#type-t">t</a></span></span></code></div></div></div></body></html>