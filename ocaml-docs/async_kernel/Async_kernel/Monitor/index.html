<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Monitor (async_kernel.Async_kernel.Monitor)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Monitor</nav><header class="odoc-preamble"><h1>Module <code><span>Async_kernel.Monitor</span></code></h1><p>The part of the <a href="../Execution_context/index.html"><code>Execution_context</code></a> that determines what to do when there is an unhandled exception.</p><p>Every Async computation runs within the context of some monitor, which, when the computation is running, is referred to as the &quot;current&quot; monitor. By default, a monitor is set up to forward exceptions to another monitor, called a parent monitor, which is always the monitor of the current execution context.</p><p>The user can &quot;detach&quot; a monitor via one of the <code>detach*</code> functions, causing the exception to no longer propagate to the parent monitor. Then whoever detached it is responsible for dealing with the exception. If the monitor is still attached, then the exception bubbles to monitor's parent. If an exception bubbles to the root of the monitor tree, that prints an unhandled-exception message and calls exit 1.</p></header><nav class="odoc-toc"><ul><li><a href="#note-about-the-toplevel-monitor">Note about the toplevel monitor</a></li></ul></nav><div class="odoc-content"><h3 id="note-about-the-toplevel-monitor"><a href="#note-about-the-toplevel-monitor" class="anchor"></a>Note about the toplevel monitor</h3><p>It is important to note that in the toplevel monitor, exceptions will only be caught in the Async part of a computation. For example, in:</p><pre><code>upon (f ()) g </code></pre><p>if <code>f</code> raises, the exception will not go to a monitor; it will go to the next caml exception handler on the stack. Any exceptions raised by <code>g</code> will be caught by the scheduler and propagated to the toplevel monitor. Because of this it is advised to always use <code>Scheduler.schedule</code> or <code>Scheduler.within</code>. For example:</p><pre><code>Scheduler.within (fun () -&gt; upon (f ()) g) </code></pre><p>This code will catch an exception in either <code>f</code> or <code>g</code>, and propagate it to the monitor.</p><p>This is only relevant to the toplevel monitor because if you create another monitor and you wish to run code within it you have no choice but to use <code>Scheduler.within</code>. <code>try_with</code> creates its own monitor and uses <code>Scheduler.within</code>, so it does not have this problem.</p><div class="odoc-spec"><div class="spec module" id="module-Deferred" class="anchored"><a href="#module-Deferred" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Deferred/index.html">Deferred</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Invariant/module-type-S/index.html">Core.Invariant.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../base/Base/Invariant/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-invariant" class="anchored"><a href="#val-invariant" class="anchor"></a><code><span><span class="keyword">val</span> invariant : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></details></div><div class="odoc-spec"><div class="spec type" id="type-with_optional_monitor_name" class="anchored"><a href="#type-with_optional_monitor_name" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a with_optional_monitor_name</span></span><span> =
  <span>?here:<a href="../../../core/Core/Source_code_position/index.html#type-t">Core.Source_code_position.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?info:<a href="../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?name:string <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> )</span> <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>create ()</code> returns a new monitor whose parent is the current monitor.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-name" class="anchored"><a href="#val-name" class="anchor"></a><code><span><span class="keyword">val</span> name : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../core/Core/Info/index.html#type-t">Core.Info.t</a></span></code></div><div class="spec-doc"><p><code>name t</code> returns the name of the monitor, or a unique id if no name was supplied to <code>create</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-current" class="anchored"><a href="#val-current" class="anchor"></a><code><span><span class="keyword">val</span> current : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>current ()</code> returns the current monitor.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-detach" class="anchored"><a href="#val-detach" class="anchor"></a><code><span><span class="keyword">val</span> detach : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>detach t</code> detaches <code>t</code>, removing its parent, so that errors raised to <code>t</code> are not passed to its former parent monitor. If those errors aren't handled in some other way (e.g. via <code>get_next_error</code>), then they will be ignored. One should usually use <code>detach_and_iter_errors</code> so that errors are not ignored.</p><p>If <code>t</code> is already detached, then <code>detach</code> does nothing. For example, it does not remove existing handlers added with <code>detach_and_iter_errors</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-detach_and_iter_errors" class="anchored"><a href="#val-detach_and_iter_errors" class="anchor"></a><code><span><span class="keyword">val</span> detach_and_iter_errors : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span>exn <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>detach_and_iter_errors t ~f</code> detaches <code>t</code> and passes to <code>f</code> all subsequent errors that reach <code>t</code>, stopping iteration if <code>f</code> raises an exception. An exception raised by <code>f</code> is sent to the monitor in effect when <code>detach_and_iter_errors</code> was called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-detach_and_get_next_error" class="anchored"><a href="#val-detach_and_get_next_error" class="anchor"></a><code><span><span class="keyword">val</span> detach_and_get_next_error : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <a href="../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>detach_and_get_next_error t</code> detaches <code>t</code> and returns a deferred that becomes determined with the next error that reaches <code>t</code> (possibly never).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-detach_and_get_error_stream" class="anchored"><a href="#val-detach_and_get_error_stream" class="anchor"></a><code><span><span class="keyword">val</span> detach_and_get_error_stream : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <a href="../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span></span></code></div><div class="spec-doc"><p><code>detach_and_get_error_stream t</code> detaches <code>t</code> and returns a stream of all subsequent errors that reach <code>t</code>.</p><p><code>Stream.iter (detach_and_get_error_stream t) ~f</code> is equivalent to <code>detach_and_iter_errors t ~f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_next_error" class="anchored"><a href="#val-get_next_error" class="anchor"></a><code><span><span class="keyword">val</span> get_next_error : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <a href="../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>get_next_error t</code> returns a deferred that becomes determined the next time <code>t</code> gets an error, if ever. Calling <code>get_next_error t</code> does not detach <code>t</code>, and if no other call has detached <code>t</code>, then errors will still bubble up the monitor tree. That includes the error returned by <code>get_next_error</code>, which will then be handled twice.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Monitor_exn" class="anchored"><a href="#module-Monitor_exn" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Monitor_exn/index.html">Monitor_exn</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension" id="extension-decl-Monitor_exn" class="anchored"><a href="#extension-decl-Monitor_exn" class="anchor"></a><code><span><span class="keyword">type</span> exn += </span></code><table><tr id="extension-Monitor_exn" class="anchored"><td class="def extension"><a href="#extension-Monitor_exn" class="anchor"></a><code><span>| </span><span><span class="extension">Monitor_exn</span> <span class="keyword">of</span> <a href="Monitor_exn/index.html#type-t">Monitor_exn.t</a></span></code></td></tr></table></div><div class="spec-doc"><p>When <code>extract_exn</code> is set to false, exceptions returned by <code>try_with</code> are wrapped into this exception type which also provides backtrace information.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extract_exn" class="anchored"><a href="#val-extract_exn" class="anchor"></a><code><span><span class="keyword">val</span> extract_exn : <span>exn <span class="arrow">&#45;&gt;</span></span> exn</span></code></div><div class="spec-doc"><p><code>extract_exn exn</code> extracts the exn from an error exn that comes from a monitor. If it is not supplied such an error exn, it returns the exn itself. It removes the backtrace from the error (see discussion in <code>try_with</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-has_seen_error" class="anchored"><a href="#val-has_seen_error" class="anchor"></a><code><span><span class="keyword">val</span> has_seen_error : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_seen_error t</code> returns true iff the monitor has ever seen an error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-send_exn" class="anchored"><a href="#val-send_exn" class="anchor"></a><code><span><span class="keyword">val</span> send_exn : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?backtrace:<span>[ `Get <span><span>| `This</span> of <a href="../../../base/Base/Backtrace/index.html#type-t">Core.Backtrace.t</a></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>exn <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>send_exn t exn ?backtrace</code> sends the exception <code>exn</code> as an error to be handled by monitor <code>t</code>. If the backtrace is not specified, it defaults to <code>`Get</code>, which means that the backtrace will be collected automatically. Automatic backtrace collection only works if <code>exn</code> is the most recently raised exception.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-try_with" class="anchored"><a href="#val-try_with" class="anchor"></a><code><span><span class="keyword">val</span> try_with : 
  <span><span>( <span>?extract_exn:bool <span class="arrow">&#45;&gt;</span></span>
    <span>?run:<span>[ `Now <span>| `Schedule</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
    <span>?rest:<span>[ `Log <span>| `Raise</span> <span><span>| `Call</span> of <span>exn <span class="arrow">&#45;&gt;</span></span> unit</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span><span>( <span class="type-var">'a</span>, exn )</span> <a href="../../../core/Core/Result/index.html#type-t">Core.Result.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span>
    <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>try_with f</code> runs <code>f ()</code> in a monitor and returns the result as <code>Ok x</code> if <code>f</code> finishes normally, or returns <code>Error e</code> if there is an exception. It either runs <code>f</code> now, if <code>run = `Now</code>, or schedules a job to run <code>f</code>, if <code>run = `Schedule</code>. Once a result is returned, subsequent exceptions raised to the monitor are handled according to <code>rest</code>:</p><ul><li><code>`Log</code>: Logged to a global error log (cannot raise).</li><li><code>`Raise</code>: Reraised to the monitor of <code>try_with</code>'s caller.</li><li><code>`Call f</code>: Passed to <code>f</code> within the context of the monitor of <code>try_with</code>'s caller.</li></ul><p>The <code>name</code> argument is used to give a name to the monitor the computation will be running in. This name will appear when printing errors.</p><p>If <code>extract_exn = true</code>, then in an <code>Error exn</code> result, the <code>exn</code> will be the actual exception raised by the computation. If <code>extract_exn = false</code>, then the <code>exn</code> will include additional information, like the monitor and backtrace.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-try_with_or_error" class="anchored"><a href="#val-try_with_or_error" class="anchor"></a><code><span><span class="keyword">val</span> try_with_or_error : 
  <span><span>( <span>?extract_exn:bool <span class="arrow">&#45;&gt;</span></span>
    <span>?rest:<span>[ `Log <span>| `Raise</span> <span><span>| `Call</span> of <span>exn <span class="arrow">&#45;&gt;</span></span> unit</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span>
    <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>try_with_or_error</code> is like <code>try_with</code> but returns <code>'a Or_error.t Deferred.t</code> instead of <code>('a,exn) Result.t Deferred.t</code>. More precisely:</p><pre><code>try_with_or_error f ?extract_exn ~rest
= try_with f ?extract_exn ~run:`Now ~rest &gt;&gt;| Or_error.of_exn_result </code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-try_with_join_or_error" class="anchored"><a href="#val-try_with_join_or_error" class="anchor"></a><code><span><span class="keyword">val</span> try_with_join_or_error : 
  <span><span>( <span>?extract_exn:bool <span class="arrow">&#45;&gt;</span></span>
    <span>?rest:<span>[ `Log <span>| `Raise</span> <span><span>| `Call</span> of <span>exn <span class="arrow">&#45;&gt;</span></span> unit</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span>
    <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>try_with_join_or_error f = try_with_or_error f &gt;&gt;| Or_error.join</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-handle_errors" class="anchored"><a href="#val-handle_errors" class="anchor"></a><code><span><span class="keyword">val</span> handle_errors : 
  <span><span>( <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span>( <span>exn <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span>
    <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>handle_errors ?name f handler</code> runs <code>f ()</code> inside a new monitor with the optionally supplied name, and calls <code>handler error</code> on every error raised to that monitor. Any error raised by <code>handler</code> goes to the monitor in effect when <code>handle_errors</code> was called.</p><p>Errors that are raised after <code>f ()</code> becomes determined will still be sent to <code>handler</code>, i.e., the new monitor lives as long as jobs created by <code>f</code> live.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-catch_stream" class="anchored"><a href="#val-catch_stream" class="anchor"></a><code><span><span class="keyword">val</span> catch_stream : 
  <span><span>( <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span>exn <a href="../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span> )</span> <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>catch_stream ?name f</code> runs <code>f ()</code> inside a new monitor <code>m</code> and returns the stream of errors raised to <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-catch" class="anchored"><a href="#val-catch" class="anchor"></a><code><span><span class="keyword">val</span> catch : <span><span>( <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span>exn <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>catch ?name f</code> runs <code>f ()</code> inside a new monitor <code>m</code> and returns the first error raised to <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-catch_error" class="anchored"><a href="#val-catch_error" class="anchor"></a><code><span><span class="keyword">val</span> catch_error : 
  <span><span>( <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../core/Core/Error/index.html#type-t">Core.Error.t</a> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>catch_error ?name f</code> runs <code>f ()</code> inside of a new monitor <code>m</code> and returns the first error raised to <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-protect" class="anchored"><a href="#val-protect" class="anchor"></a><code><span><span class="keyword">val</span> protect : 
  <span><span>( <span>?extract_exn:bool <span class="arrow">&#45;&gt;</span></span>
    <span>?run:<span>[ `Now <span>| `Schedule</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
    <span>?rest:<span>[ `Log <span>| `Raise</span> <span><span>| `Call</span> of <span>exn <span class="arrow">&#45;&gt;</span></span> unit</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
    <span>finally:<span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span>
    <a href="#type-with_optional_monitor_name">with_optional_monitor_name</a></span></span></code></div><div class="spec-doc"><p><code>protect f ~finally</code> runs <code>f ()</code> and then <code>finally</code> regardless of the success or failure of <code>f</code>. It re-raises any exception thrown by <code>f</code> or returns whatever <code>f</code> returned.</p><p>The <code>name</code> argument is used to give a name to the monitor the computation will be running in. This name will appear when printing the errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-main" class="anchored"><a href="#val-main" class="anchor"></a><code><span><span class="keyword">val</span> main : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>This is the initial monitor and is the root of the monitor tree. Unhandled exceptions are raised to this monitor.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Expert" class="anchored"><a href="#module-Expert" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Expert/index.html">Expert</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Exported_for_scheduler" class="anchored"><a href="#module-Exported_for_scheduler" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Exported_for_scheduler/index.html">Exported_for_scheduler</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-For_tests" class="anchored"><a href="#module-For_tests" class="anchor"></a><code><span><span class="keyword">module</span> <a href="For_tests/index.html">For_tests</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>