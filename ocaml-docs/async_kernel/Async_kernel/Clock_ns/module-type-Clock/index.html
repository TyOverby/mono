<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Clock (async_kernel.Async_kernel.Clock_ns.Clock)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">async_kernel</a> &#x00BB; <a href="../../index.html">Async_kernel</a> &#x00BB; <a href="../index.html">Clock_ns</a> &#x00BB; Clock</nav><header class="odoc-preamble"><h1>Module type <code><span>Clock_ns.Clock</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Or_timeout" class="anchored"><a href="#module-Or_timeout" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Or_timeout/index.html">Or_timeout</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Time" class="anchored"><a href="#module-Time" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Time/index.html">Time</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-run_at" class="anchored"><a href="#val-run_at" class="anchor"></a><code><span><span class="keyword">val</span> run_at : <span><a href="Time/index.html#type-t">Time.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>run_at time f a</code> runs <code>f a</code> as soon as possible after <code>time</code>. If <code>time</code> is in the past, then <code>run_at</code> will immediately schedule a job <code>t</code> that will run <code>f a</code>. In no situation will <code>run_at</code> actually call <code>f</code> itself. The call to <code>f</code> will always be in another job.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_after" class="anchored"><a href="#val-run_after" class="anchor"></a><code><span><span class="keyword">val</span> run_after : <span><a href="Time/Span/index.html#type-t">Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>run_after</code> is like <code>run_at</code>, except that one specifies a time span rather than an absolute time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-at" class="anchored"><a href="#val-at" class="anchor"></a><code><span><span class="keyword">val</span> at : <span><a href="Time/index.html#type-t">Time.t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>at time</code> returns a deferred <code>d</code> that will become determined as soon as possible after <code>time</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-after" class="anchored"><a href="#val-after" class="anchor"></a><code><span><span class="keyword">val</span> after : <span><a href="Time/Span/index.html#type-t">Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>after</code> is like <code>at</code>, except that one specifies a time span rather than an absolute time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_timeout" class="anchored"><a href="#val-with_timeout" class="anchor"></a><code><span><span class="keyword">val</span> with_timeout : <span><a href="Time/Span/index.html#type-t">Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="Or_timeout/index.html#type-t">Or_timeout.t</a></span> <a href="../../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>with_timeout span d</code> returns a deferred that will become determined after either <code>span</code> elapses or <code>d</code> is determined, returning either <code>`Timeout</code> or <code>`Result</code> depending on which one succeeded first. At the time the returned deferred becomes determined, both things may have happened, in which case <code>`Result</code> is given preference.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Event" class="anchored"><a href="#module-Event" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Event/index.html">Event</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Events provide variants of <code>run_at</code> and <code>run_after</code> with the ability to abort or reschedule an event that hasn't yet happened. Once an event happens or is aborted, Async doesn't use any space for tracking it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-at_varying_intervals" class="anchored"><a href="#val-at_varying_intervals" class="anchor"></a><code><span><span class="keyword">val</span> at_varying_intervals : 
  <span>?stop:<span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="../../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span></span></code></div><div class="spec-doc"><p><code>at_varying_intervals f ?stop</code> returns a stream whose next element becomes determined by calling <code>f ()</code> and waiting for that amount of time, and then looping to determine subsequent elements. The stream will end after <code>stop</code> becomes determined.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-at_intervals" class="anchored"><a href="#val-at_intervals" class="anchor"></a><code><span><span class="keyword">val</span> at_intervals : 
  <span>?start:<a href="Time/index.html#type-t">Time.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?stop:<span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Time/Span/index.html#type-t">Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="../../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span></span></code></div><div class="spec-doc"><p><code>at_intervals interval ?start ?stop</code> returns a stream whose elements will become determined at nonnegative integer multiples of <code>interval</code> after the <code>start</code> time, until <code>stop</code> becomes determined:</p><pre>        start + 0 * interval
        start + 1 * interval
        start + 2 * interval
        start + 3 * interval
        ...</pre><p>Note that only elements that are strictly in the future ever become determined. In particular, if <code>start</code> is not in the future, or <code>start</code> is not provided, then there will be no element before the <code>interval</code> has passed.</p><p>If the interval is too small or the CPU is too loaded, <code>at_intervals</code> will skip until the next upcoming multiple of <code>interval</code> after <code>start</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-every'" class="anchored"><a href="#val-every'" class="anchor"></a><code><span><span class="keyword">val</span> every' : 
  <span>?start:<span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?stop:<span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?continue_on_error:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?finished:<span>unit <a href="../../Ivar/index.html#type-t">Ivar.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Time/Span/index.html#type-t">Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>every' ?start ?stop span f</code> runs <code>f ()</code> every <code>span</code> amount of time starting when <code>start</code> becomes determined and stopping when <code>stop</code> becomes determined. <code>every'</code> waits until the outcome of <code>f ()</code> becomes determined before waiting for the next <code>span</code>.</p><p>It is guaranteed that if <code>stop</code> becomes determined, even during evaluation of <code>f</code>, then <code>f</code> will not be called again by a subsequent iteration of the loop.</p><p>It is an error for <code>span</code> to be nonpositive.</p><p><code>continue_on_error</code> controls what should happen if <code>f</code> raises an exception. With <code>~continue_on_error:false</code>, iteration only continues if <code>f</code> successfully returns a deferred and that deferred is determined. With <code>~continue_on_error:true</code>, iteration also continues if <code>f</code> raises an exception. If <code>f</code> raises an exception asynchronously, this may cause us to proceed with the next iteration while the previous call to <code>f</code> is still running.</p><p>Exceptions raised by <code>f</code> are always sent to the monitor in effect when <code>every'</code> was called, even with <code>~continue_on_error:true</code>.</p><p>If <code>finished</code> is supplied, <code>every'</code> will fill it once all of the following become determined: <code>start</code>, <code>stop</code>, and the outcome of the final call to <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-every" class="anchored"><a href="#val-every" class="anchor"></a><code><span><span class="keyword">val</span> every : 
  <span>?start:<span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?stop:<span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?continue_on_error:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Time/Span/index.html#type-t">Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>every ?start ?stop span f</code> is <code>every' ?start ?stop span (fun () -&gt; f (); return ())</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_at_intervals'" class="anchored"><a href="#val-run_at_intervals'" class="anchor"></a><code><span><span class="keyword">val</span> run_at_intervals' : 
  <span>?start:<a href="Time/index.html#type-t">Time.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?stop:<span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?continue_on_error:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Time/Span/index.html#type-t">Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>run_at_intervals' ?start ?stop span f</code> runs <code>f()</code> at increments of <code>start + i *
      span</code> for nonnegative integers <code>i</code>, until <code>stop</code> becomes determined. If the result of <code>f</code> is not determined fast enough then the next interval(s) are skipped so that there are never multiple concurrent invocations of <code>f</code> in flight.</p><p>Exceptions raised by <code>f</code> are always sent to monitor in effect when <code>run_at_intervals'</code> was called, even with <code>~continue_on_error:true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_at_intervals" class="anchored"><a href="#val-run_at_intervals" class="anchor"></a><code><span><span class="keyword">val</span> run_at_intervals : 
  <span>?start:<a href="Time/index.html#type-t">Time.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?stop:<span>unit <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?continue_on_error:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Time/Span/index.html#type-t">Time.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>run_at_intervals ?start ?stop ?continue_on_error span f</code> is equivalent to:</p><pre><code>run_at_intervals' ?start ?stop ?continue_on_error span
  (fun () -&gt; f (); return ()) </code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-duration_of" class="anchored"><a href="#val-duration_of" class="anchor"></a><code><span><span class="keyword">val</span> duration_of : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <a href="Time/Span/index.html#type-t">Time.Span.t</a>)</span> <a href="../../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>duration_of f</code> invokes <code>f ()</code> and measures how long it takes from the invocation to after the deferred is determined.</p><p>Note that the measurement is not exact; because it involves an additional map on the deferred, the timing also includes the duration of jobs in the job queue when <code>f ()</code> is determined.</p></div></div></div></body></html>