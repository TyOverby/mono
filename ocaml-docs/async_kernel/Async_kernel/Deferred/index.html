<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Deferred (async_kernel.Async_kernel.Deferred)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Deferred</nav><header class="odoc-preamble"><h1>Module <code><span>Async_kernel.Deferred</span></code></h1><p>A value that will become determined asynchronously.</p><p>A deferred can be &quot;undetermined&quot; or &quot;determined&quot;. A deferred that is undetermined may at some point become determined with value v, and will henceforth always be determined with value v.</p></header><nav class="odoc-toc"><ul><li><a href="#deferred-collections">Deferred collections</a></li><li><a href="#error-carrying-deferreds">Error-carrying deferreds</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a t</span></span><span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Invariant/module-type-S1/index.html">Core.Invariant.S1</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../base/Base/Invariant/module-type-S1/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-invariant" class="anchored"><a href="#val-invariant" class="anchor"></a><code><span><span class="keyword">val</span> invariant : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></details></div><p><code>sexp_of_t t f</code> returns a sexp of the deferred's value, if it is determined, or an informative string otherwise.</p><p>This is just for display purposes. There is no <code>t_of_sexp</code>.</p><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span>( <span><span><span class="type-var">'a</span> <a href="../Ivar/index.html#type-t">Ivar.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create f</code> calls <code>f i</code>, where <code>i</code> is an empty ivar. <code>create</code> returns a deferred that becomes determined when <code>f</code> fills <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-upon" class="anchored"><a href="#val-upon" class="anchor"></a><code><span><span class="keyword">val</span> upon : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>upon t f</code> will run <code>f v</code> at some point after <code>t</code> becomes determined with value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>peek t</code> returns <code>Some v</code> iff <code>t</code> is determined with value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-value_exn" class="anchored"><a href="#val-value_exn" class="anchor"></a><code><span><span class="keyword">val</span> value_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>value_exn t</code> returns <code>v</code> if <code>t</code> is determined with value <code>v</code>, and raises otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_determined" class="anchored"><a href="#val-is_determined" class="anchor"></a><code><span><span class="keyword">val</span> is_determined : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_determined t</code> returns <code>true</code> iff <code>t</code> is determined.</p></div></div><div class="odoc-include"><div class="spec-doc"><p>Deferreds form a monad.</p><p><code>let%bind v = t in f v</code> returns a deferred <code>t'</code> that waits until <code>t</code> is determined with value <code>v</code>, at which point it waits for <code>f v</code> to become determined with value <code>v'</code>, to which <code>t'</code> will become determined.</p><p><code>return v</code> returns a deferred that is immediately determined with value v.</p><p>Note that:</p><pre><code>upon t f </code></pre><p>is more efficient than:</p><pre><code>ignore (let%bind a = t in f a; return ()) </code></pre><p>because <code>upon</code>, unlike <code>let%bind</code>, does not create a deferred to hold the result.</p><p>For example, one can write a loop that has good constant factors with:</p><pre><code>let rec loop () =
  upon t (fun a -&gt; ... loop () ... ) </code></pre><p>although often <code>forever</code> or <code>repeat_until_finished</code> is more clear.</p><p>The same loop written with <code>let%bind</code> would allocate deferreds that would be immediately garbage collected. (In the past, this loop would have also used linear space in recursion depth!)</p><p>In general, for deferreds that are allocated by <code>let%bind</code> to be garbage collected quickly, it is sufficient that the allocating bind be executed in tail-call position of the right-hand side of an outer bind.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Monad/module-type-S/index.html">Core.Monad</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../base/Base/Monad/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-include"><div class="odoc-include"><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t &gt;&gt;= f</code> returns a computation that sequences the computations represented by two monad elements. The resulting computation first does <code>t</code> to yield a value <code>v</code>, and then runs the computation returned by <code>f v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t &gt;&gt;| f</code> is <code>t &gt;&gt;= (fun a -&gt; return (f a))</code>.</p></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Monad_infix" class="anchored"><a href="#module-Monad_infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bind t ~f</code> = <code>t &gt;&gt;= f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return v</code> returns the (trivial) computation that returns v.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map t ~f</code> is t &gt;&gt;| f.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join t</code> is <code>t &gt;&gt;= (fun t' -&gt; t')</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ignore_m" class="anchored"><a href="#val-ignore_m" class="anchor"></a><code><span><span class="keyword">val</span> ignore_m : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ignore_m t</code> is <code>map t ~f:(fun _ -&gt; ())</code>. <code>ignore_m</code> used to be called <code>ignore</code>, but we decided that was a bad name, because it shadowed the widely used <code>Caml.ignore</code>. Some monads still do <code>let ignore = ignore_m</code> for historical reasons.</p></div></div></div><div class="odoc-include"><div class="odoc-spec"><div class="spec module" id="module-Let_syntax" class="anchored"><a href="#module-Let_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>These are convenient to have in scope when programming with a monad:</p></div></div></div></details></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span><span class="keyword">val</span> unit : <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unit</code> is a deferred that is always determined with value <code>()</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-never" class="anchored"><a href="#val-never" class="anchor"></a><code><span><span class="keyword">val</span> never : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">_</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>never ()</code> returns a deferred that never becomes determined.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-both" class="anchored"><a href="#val-both" class="anchor"></a><code><span><span class="keyword">val</span> both : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>both t1 t2</code> becomes determined after both <code>t1</code> and <code>t2</code> become determined.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>all ts</code> returns a deferred that becomes determined when every <code>t</code> in <code>t</code>s is determined. The output is in the same order as the input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span><span class="keyword">val</span> all_unit : <span><span><span>unit <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Like <code>all</code>, but ignores results of the component deferreds.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span><span class="keyword">val</span> any : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>any ts</code> returns a deferred that is determined when any of the underlying deferreds is determined.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any_unit" class="anchored"><a href="#val-any_unit" class="anchor"></a><code><span><span class="keyword">val</span> any_unit : <span><span><span>unit <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>any_unit</code> is like <code>any</code>, but ignores results of the component deferreds.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-don't_wait_for" class="anchored"><a href="#val-don't_wait_for" class="anchor"></a><code><span><span class="keyword">val</span> don't_wait_for : <span><span>unit <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>don't_wait_for t</code> ignores <code>t</code>. It is like <code>Fn.ignore</code>, but is more constrained because it requires a <code>unit Deferred.t</code>.</p><p>Rather than <code>ignore (t : _ t)</code>, do <code>don't_wait_for (Deferred.ignore_m t)</code>.</p><p>We chose to give <code>don't_wait_for</code> type <code>unit t</code> rather than <code>_ t</code> to catch errors where a value is accidentally ignored.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Choice" class="anchored"><a href="#module-Choice" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Choice/index.html">Choice</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A <code>Choice.t</code> is used to produce an argument to <code>enabled</code> or <code>choose</code>. See below.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-choice" class="anchored"><a href="#val-choice" class="anchor"></a><code><span><span class="keyword">val</span> choice : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-enabled" class="anchored"><a href="#val-enabled" class="anchor"></a><code><span><span class="keyword">val</span> enabled : <span><span><span><span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>enabled [choice t1 f1; ... choice tn fn;]</code> returns a deferred <code>d</code> that becomes determined when any of the <code>ti</code> becomes determined. The value of <code>d</code> is a function <code>f</code> that when called, for each <code>ti</code> that is enabled, applies <code>fi</code> to <code>ti</code>, and returns a list of the results. It is guaranteed that the list is in the same order as the choices supplied to <code>enabled</code>, but of course it may be shorter than the input list if not all <code>ti</code> are determined.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-choose" class="anchored"><a href="#val-choose" class="anchor"></a><code><span><span class="keyword">val</span> choose : <span><span><span><span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><pre><code>choose [ choice t1 f1
       ; ...
         ; choice tn fn ] </code></pre><p>returns a deferred <code>t</code> that becomes determined with value <code>fi ai</code> after some <code>ti</code> becomes determined with value <code>ai</code>. It is guaranteed that <code>choose</code> calls at most one of the <code>fi</code>s, the one that determines its result. There is no guarantee that the <code>ti</code> that becomes determined earliest in time will be the one whose value determines the <code>choose</code>. Nor is it guaranteed that the value in <code>t</code> is the first value (in place order) from <code>choices</code> that is determined at the time <code>t</code> is examined.</p><p>For example, in:</p><pre><code>choose [ choice t1 (fun () -&gt; `X1)
       ; choice t2 (fun () -&gt; `X2) ]
&gt;&gt;&gt; function
| `X1 -&gt; e1
| `X2 -&gt; e2 </code></pre><p>it may be the case that both <code>t1</code> and <code>t2</code> become determined, yet <code>e2</code> actually runs.</p><p>It is guaranteed that if multiple choices are determined with no intervening asynchrony, then the earliest choice in the list will become the value of the <code>choose</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_" class="anchored"><a href="#val-for_" class="anchor"></a><code><span><span class="keyword">val</span> for_ : <span>int <span class="arrow">&#45;&gt;</span></span> <span>to_:int <span class="arrow">&#45;&gt;</span></span> <span>do_:<span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>for_ start ~to_:stop ~do_:f</code> is the deferred analog of:</p><pre><code>for i = start to stop do
  f i;
done </code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat_until_finished" class="anchored"><a href="#val-repeat_until_finished" class="anchor"></a><code><span><span class="keyword">val</span> repeat_until_finished : 
  <span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span><span>[ <span>`Repeat of <span class="type-var">'state</span></span> <span><span>| `Finished</span> of <span class="type-var">'result</span></span> ]</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'result</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>repeat_until_finished initial_state f</code> repeatedly runs <code>f</code> until <code>f</code> returns <code>`Finished</code>. The first call to <code>f</code> happens immediately when <code>repeat_until_finished</code> is called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-forever" class="anchored"><a href="#val-forever" class="anchor"></a><code><span><span class="keyword">val</span> forever : <span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'state</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>forever initial_state f</code> repeatedly runs <code>f</code>, supplying the state returned to the next call to <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ok" class="anchored"><a href="#val-ok" class="anchor"></a><code><span><span class="keyword">val</span> ok : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">_</span> )</span> <a href="../../../core/Core/Result/index.html#type-t">Core.Result.t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Useful for lifting values from the <code>Deferred.t</code> monad to the <code>Result.t Deferred.t</code> monad.</p></div></div><h3 id="deferred-collections"><a href="#deferred-collections" class="anchor"></a>Deferred collections</h3><p>These contain operations for iterating in a deferred manner over different collection types.</p><div class="odoc-spec"><div class="spec module" id="module-Array" class="anchored"><a href="#module-Array" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Array/index.html">Array</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-List" class="anchored"><a href="#module-List" class="anchor"></a><code><span><span class="keyword">module</span> <a href="List/index.html">List</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Memo" class="anchored"><a href="#module-Memo" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Memo/index.html">Memo</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Memoization functions like in <code>Core.Memo</code>, with re-raising of exceptions thrown asynchronously.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Queue" class="anchored"><a href="#module-Queue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Queue/index.html">Queue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>All <code>Deferred_queue</code> iteration functions first copy the queue (to a list) and then start calling the user function <code>f</code>. So, if <code>f</code> modifies the queue, that will have no effect on the iteration.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Sequence" class="anchored"><a href="#module-Sequence" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sequence/index.html">Sequence</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="error-carrying-deferreds"><a href="#error-carrying-deferreds" class="anchor"></a>Error-carrying deferreds</h3><p>These contain interfaces for working with deferred type containing error-aware types, like <code>'a Option.t Deferred.t</code>, or <code>'a Or_error.t Deferred.t</code>. These all include support for monadic programming.</p><div class="odoc-spec"><div class="spec module" id="module-Option" class="anchored"><a href="#module-Option" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Option/index.html">Option</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Or_error" class="anchored"><a href="#module-Or_error" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Or_error/index.html">Or_error</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The deferred analog of <code>Core.Or_error</code>. It is exposed in std.ml as <code>Deferred.Or_error</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Result" class="anchored"><a href="#module-Result" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Result/index.html">Result</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>