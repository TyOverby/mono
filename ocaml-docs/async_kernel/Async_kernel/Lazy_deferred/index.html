<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lazy_deferred (async_kernel.Async_kernel.Lazy_deferred)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Lazy_deferred</nav><header class="odoc-preamble"><h1>Module <code><span>Async_kernel.Lazy_deferred</span></code></h1><p>A delayed computation that can produce a deferred.</p><p>Nothing happens with a lazy deferred unless one <code>force</code>s it. Forcing a lazy deferred starts the computation, which will eventually cause the deferred to become determined. As usual with laziness, multiply forcing a lazy deferred is no different than forcing it a single time.</p><p>Exceptions (both synchronous and asynchronous) raised by a delayed computation are returned by <code>force</code> (<code>wait</code>, <code>peek</code>, etc.), or will be raised to the monitor in effect when <code>force_exn</code> (<code>wait_exn</code>, <code>peek_exn</code>, etc.) was called.</p><p>The type is not exposed nor defined as <code>'a Deferred.t Lazy.t</code> or <code>'a Or_error.t
    Deferred.t Lazy.t</code>, because there is a difference in power with these types. Any value of type <code>'a Deferred.t Lazy.t</code> would mishandle asynchronous exceptions in the computation of <code>'a</code>. For instance, the following code blocks forever regardless of how <code>v</code> is defined:</p><pre><code>let v : Nothing.t Deferred.t Lazy.t = lazy (return &quot;&quot; &gt;&gt;| failwith) in
let%bind _ = try_with (fun () -&gt; force v) in
let%bind _ = try_with (fun () -&gt; force v) in</code></pre><p>There is no <code>val of_lazy : 'a Deferred.t Lazy.t -&gt; 'a t</code> because of the difference in power.</p><p>See also <code>Deferred.Memo.unit</code>, if you only are interested in <code>create</code> and <code>force</code>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create f</code> creates a new lazy deferred that will call <code>f</code> when it is forced.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_or_error" class="anchored"><a href="#val-create_or_error" class="anchor"></a><code><span><span class="keyword">val</span> create_or_error : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Deferred/Or_error/index.html#type-t">Deferred.Or_error.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-create"><code>create</code></a> but allows <code>f</code> to explicitly return errors as well as raise. The two cases are joined and not distingused in the result of <a href="#val-force"><code>force</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-force" class="anchored"><a href="#val-force" class="anchor"></a><code><span><span class="keyword">val</span> force : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>force t</code> forces evaluation of <code>t</code> and returns a deferred that becomes determined when the deferred computation becomes determined or raises.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-force_exn" class="anchored"><a href="#val-force_exn" class="anchor"></a><code><span><span class="keyword">val</span> force_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-wait" class="anchored"><a href="#val-wait" class="anchor"></a><code><span><span class="keyword">val</span> wait : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>wait t</code> and <code>wait_exn t</code> waits for <code>t</code> to be forced. If no one ever calls <code>force t</code>, they will wait forever.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wait_exn" class="anchored"><a href="#val-wait_exn" class="anchor"></a><code><span><span class="keyword">val</span> wait_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></span></code></div></div><p>This monad is designed to let you write as though you are in a lazy language, where all computations only run when needed (forced). If your use case just has a few lazy computations and you want to reason about them the same way you reason about regular deferreds (where <code>map/bind</code> means run the next step once the previous is determined), see <code>Laziness_preserving_deferred</code>.</p><div class="odoc-include"><div class="spec-doc"><p><code>bind t f</code> in the lazy-deferred monad creates a computation that, when forced, will force <code>t</code>, apply <code>f</code> to the result, and then force the result of that.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Monad/module-type-S/index.html">Core.Monad</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../base/Base/Monad/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-include"><div class="odoc-include"><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t &gt;&gt;= f</code> returns a computation that sequences the computations represented by two monad elements. The resulting computation first does <code>t</code> to yield a value <code>v</code>, and then runs the computation returned by <code>f v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t &gt;&gt;| f</code> is <code>t &gt;&gt;= (fun a -&gt; return (f a))</code>.</p></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Monad_infix" class="anchored"><a href="#module-Monad_infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bind t ~f</code> = <code>t &gt;&gt;= f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return v</code> returns the (trivial) computation that returns v.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map t ~f</code> is t &gt;&gt;| f.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join t</code> is <code>t &gt;&gt;= (fun t' -&gt; t')</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ignore_m" class="anchored"><a href="#val-ignore_m" class="anchor"></a><code><span><span class="keyword">val</span> ignore_m : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ignore_m t</code> is <code>map t ~f:(fun _ -&gt; ())</code>. <code>ignore_m</code> used to be called <code>ignore</code>, but we decided that was a bad name, because it shadowed the widely used <code>Caml.ignore</code>. Some monads still do <code>let ignore = ignore_m</code> for historical reasons.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span><span class="keyword">val</span> all_unit : <span><span><span>unit <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Like <code>all</code>, but ensures that every monadic value in the list produces a unit value, all of which are discarded rather than being collected into a list.</p></div></div></div><div class="odoc-include"><div class="odoc-spec"><div class="spec module" id="module-Let_syntax" class="anchored"><a href="#module-Let_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>These are convenient to have in scope when programming with a monad:</p></div></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-bind'" class="anchored"><a href="#val-bind'" class="anchor"></a><code><span><span class="keyword">val</span> bind' : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bind'</code> differs from <code>bind</code> in that the supplied function produces an <code>'a Deferred.t</code> rather than an <code>'a t</code>.</p></div></div><p>Read-only operations.</p><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> option</span></span></code></div><div class="spec-doc"><p><code>peek t = Deferred.peek (wait t)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek_exn" class="anchored"><a href="#val-peek_exn" class="anchor"></a><code><span><span class="keyword">val</span> peek_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_determined" class="anchored"><a href="#val-is_determined" class="anchor"></a><code><span><span class="keyword">val</span> is_determined : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_forced" class="anchored"><a href="#val-is_forced" class="anchor"></a><code><span><span class="keyword">val</span> is_forced : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div></div></body></html>