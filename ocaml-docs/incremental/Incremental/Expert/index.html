<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Expert (incremental.Incremental.Expert)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">incremental</a> &#x00BB; <a href="../index.html">Incremental</a> &#x00BB; Expert</nav><header class="odoc-preamble"><h1>Module <code><span>Incremental.Expert</span></code></h1><p>A low-level, experimental interface to incremental. This is useful when you need more control over the dependency graph, for performance reasons. It comes at the cost that it's much harder to use right. Specifically, here is what you can do with an expert node:</p><ul><li>learn when any child changes, so the expert node can update itself incrementally, rather than having to look at the value of all its children.</li></ul><ul><li>incrementally update its set of parents.</li></ul><ul><li>select which parents should fire.</li></ul><p>If you use this interface, you are most definitely advised to test carefully, and in particular you should try it out using <code>incremental_debug</code>, which is going to check most pre-conditions.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Dependency" class="anchored"><a href="#module-Dependency" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Dependency/index.html">Dependency</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Node" class="anchored"><a href="#module-Node" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Node/index.html">Node</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Step_result" class="anchored"><a href="#module-Step_result" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Step_result/index.html">Step_result</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-do_one_step_of_stabilize" class="anchored"><a href="#val-do_one_step_of_stabilize" class="anchor"></a><code><span><span class="keyword">val</span> do_one_step_of_stabilize : <span><span><span class="type-var">_</span> <a href="../State/index.html#type-t">State.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="Step_result/index.html#type-t">Step_result.t</a></span></code></div><div class="spec-doc"><p><code>do_one_step_of_stabilize state</code> runs a part of stabilization. This can be used as a replacement for <code>stabilize</code>, to split up potentially long calls to <code>stabilize</code>.</p><p>A stabilization is ongoing until <code>do_one_step_of_stabilize</code> returns <code>Done</code>. During such a stabilization, behavior is the same as during a regular stabilization.</p><p>Calling <code>do_one_step_of_stabilize</code> during a call to <code>do_one_step_of_stabilize</code> or <code>stabilize</code> is a programming error but it is not detected. Behavior is undefined.</p></div></div></div></body></html>