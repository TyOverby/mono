<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sexp (core.Core.Sexp)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">core</a> &#x00BB; <a href="../index.html">Core</a> &#x00BB; Sexp</nav><header class="odoc-preamble"><h1>Module <code><span>Core.Sexp</span></code></h1><p>Code for managing s-expressions.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../../../base/Base/Sexp/index.html#type-t">Base.Sexp.t</a></span><span> = </span></code><table><tr id="type-t.Atom" class="anchored"><td class="def variant constructor"><a href="#type-t.Atom" class="anchor"></a><code><span>| </span><span><span class="constructor">Atom</span> <span class="keyword">of</span> <a href="../../../base/Base/String/index.html#type-t">Base.String.t</a></span></code></td></tr><tr id="type-t.List" class="anchored"><td class="def variant constructor"><a href="#type-t.List" class="anchor"></a><code><span>| </span><span><span class="constructor">List</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> <a href="../../../base/Base/List/index.html#type-t">Base.List.t</a></span></span></code></td></tr></table></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../bin_prot/Bin_prot/Binable/module-type-S/index.html">Bin_prot.Binable.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../bin_prot/Bin_prot/Binable/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../bin_prot/Bin_prot/Binable/module-type-S_only_functions/index.html">Bin_prot.Binable.S_only_functions</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../bin_prot/Bin_prot/Binable/module-type-S_only_functions/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-bin_size_t" class="anchored"><a href="#val-bin_size_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_size_t : <span><a href="#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_write_t" class="anchored"><a href="#val-bin_write_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_write_t : <span><a href="#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_read_t" class="anchored"><a href="#val-bin_read_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_read_t : <span><a href="#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-__bin_read_t__" class="anchored"><a href="#val-__bin_read_t__" class="anchor"></a><code><span><span class="keyword">val</span> __bin_read_t__ : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> )</span> <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span></span></code></div><div class="spec-doc"><p>This function only needs implementation if <code>t</code> exposed to be a polymorphic variant. Despite what the type reads, this does *not* produce a function after reading; instead it takes the constructor tag (int) before reading and reads the rest of the variant <code>t</code> afterwards.</p></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-bin_shape_t" class="anchored"><a href="#val-bin_shape_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_shape_t : <a href="../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_writer_t" class="anchored"><a href="#val-bin_writer_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_writer_t : <span><a href="#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_reader_t" class="anchored"><a href="#val-bin_reader_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_reader_t : <span><a href="#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_t" class="anchored"><a href="#val-bin_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_t : <span><a href="#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></span></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../ppx_hash/Ppx_hash_lib/Hashable/module-type-S/index.html">Ppx_hash_lib.Hashable.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../ppx_hash/Ppx_hash_lib/Hashable/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-hash_fold_t" class="anchored"><a href="#val-hash_fold_t" class="anchor"></a><code><span><span class="keyword">val</span> hash_fold_t : <span><a href="../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-hash" class="anchored"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../base/Base/Hash/index.html#type-hash_value">Base.Hash.hash_value</a></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Sexplib0</span>.Sexpable.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-t_of_sexp" class="anchored"><a href="#val-t_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> t_of_sexp : <span><span class="xref-unresolved">Sexplib0__</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0__</span>.Sexp.t</span></code></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-t_sexp_grammar" class="anchored"><a href="#val-t_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> t_sexp_grammar : <span><a href="#type-t">t</a> <span class="xref-unresolved">Sexplib0</span>.Sexp_grammar.t</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-O" class="anchored"><a href="#module-O" class="anchor"></a><code><span><span class="keyword">module</span> <a href="O/index.html">O</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Comparable/module-type-S/index.html">Comparable.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Comparable/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-include"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Comparable/module-type-S/index.html">Base.Comparable.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../base/Base/Comparable/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Comparisons/module-type-S/index.html">Base.Comparisons.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../base/Base/Comparisons/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Comparisons/module-type-Infix/index.html">Base.Comparisons.Infix</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../base/Base/Comparisons/module-type-Infix/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-(&gt;=)" class="anchored"><a href="#val-(&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;=)" class="anchored"><a href="#val-(&lt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(=)" class="anchored"><a href="#val-(=)" class="anchor"></a><code><span><span class="keyword">val</span> (=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;)" class="anchored"><a href="#val-(&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;)" class="anchored"><a href="#val-(&lt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;&gt;)" class="anchored"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;&gt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-min" class="anchored"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-max" class="anchored"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-ascending" class="anchored"><a href="#val-ascending" class="anchor"></a><code><span><span class="keyword">val</span> ascending : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>ascending</code> is identical to <code>compare</code>. <code>descending x y = ascending y x</code>. These are intended to be mnemonic when used like <code>List.sort ~compare:ascending</code> and <code>List.sort
      ~cmp:descending</code>, since they cause the list to be sorted in ascending or descending order, respectively.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-descending" class="anchored"><a href="#val-descending" class="anchor"></a><code><span><span class="keyword">val</span> descending : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-between" class="anchored"><a href="#val-between" class="anchor"></a><code><span><span class="keyword">val</span> between : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>low:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>high:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>between t ~low ~high</code> means <code>low &lt;= t &lt;= high</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-clamp_exn" class="anchored"><a href="#val-clamp_exn" class="anchor"></a><code><span><span class="keyword">val</span> clamp_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>min:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>max:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>clamp_exn t ~min ~max</code> returns <code>t'</code>, the closest value to <code>t</code> such that <code>between t' ~low:min ~high:max</code> is true.</p><p>Raises if <code>not (min &lt;= max)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clamp" class="anchored"><a href="#val-clamp" class="anchor"></a><code><span><span class="keyword">val</span> clamp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>min:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>max:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../../../base/Base/Or_error/index.html#type-t">Base.Or_error.t</a></span></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Comparator/module-type-S/index.html">Base.Comparator.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../base/Base/Comparator/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-comparator_witness" class="anchored"><a href="#type-comparator_witness" class="anchor"></a><code><span><span class="keyword">type</span> comparator_witness</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-comparator" class="anchored"><a href="#val-comparator" class="anchor"></a><code><span><span class="keyword">val</span> comparator : <span><span>( <a href="#type-t">t</a>, <a href="#type-comparator_witness">comparator_witness</a> )</span> <a href="../../../base/Base/Comparator/index.html#type-comparator">Base.Comparator.comparator</a></span></span></code></div></div></details></div></details></div><div class="odoc-include"><div class="odoc-spec"><div class="spec value" id="val-validate_lbound" class="anchored"><a href="#val-validate_lbound" class="anchor"></a><code><span><span class="keyword">val</span> validate_lbound : <span>min:<span><a href="#type-t">t</a> <a href="../Maybe_bound/index.html#type-t">Maybe_bound.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../../Validate/index.html#type-check">Validate.check</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-validate_ubound" class="anchored"><a href="#val-validate_ubound" class="anchor"></a><code><span><span class="keyword">val</span> validate_ubound : <span>max:<span><a href="#type-t">t</a> <a href="../Maybe_bound/index.html#type-t">Maybe_bound.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../../Validate/index.html#type-check">Validate.check</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-validate_bound" class="anchored"><a href="#val-validate_bound" class="anchor"></a><code><span><span class="keyword">val</span> validate_bound : 
  <span>min:<span><a href="#type-t">t</a> <a href="../Maybe_bound/index.html#type-t">Maybe_bound.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>max:<span><a href="#type-t">t</a> <a href="../Maybe_bound/index.html#type-t">Maybe_bound.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <a href="../../Validate/index.html#type-check">Validate.check</a></span></span></code></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Replace_polymorphic_compare" class="anchored"><a href="#module-Replace_polymorphic_compare" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Replace_polymorphic_compare/index.html">Replace_polymorphic_compare</a></span><span> : 
  <a href="../../../base/Base/Comparisons/module-type-S/index.html">Base.Comparable.Polymorphic_compare</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../base/Base/Comparisons/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Map/index.html">Map</a></span><span> : 
  <a href="../Map_intf/module-type-S/index.html">Map.S</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Map_intf/module-type-S/Key/index.html#type-t">Key.t</a> = <a href="#type-t">t</a></span>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Map_intf/module-type-S/Key/index.html#type-comparator_witness">Key.comparator_witness</a> = <a href="#type-comparator_witness">comparator_witness</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Set" class="anchored"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Set/index.html">Set</a></span><span> : 
  <a href="../Set_intf/module-type-S/index.html">Set.S</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Set_intf/module-type-S/Elt/index.html#type-t">Elt.t</a> = <a href="#type-t">t</a></span>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Set_intf/module-type-S/Elt/index.html#type-comparator_witness">Elt.comparator_witness</a> = <a href="#type-comparator_witness">comparator_witness</a></span></span></code></div></div></details></div><div class="odoc-include shadowed-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../base/Base/Stringable/module-type-S/index.html">Base.Stringable.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../base/Base/Stringable/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Quickcheck_intf/module-type-S/index.html">Quickcheckable.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Quickcheck_intf/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-quickcheck_generator" class="anchored"><a href="#val-quickcheck_generator" class="anchor"></a><code><span><span class="keyword">val</span> quickcheck_generator : <span><a href="#type-t">t</a> <a href="../../../base_quickcheck/Base_quickcheck/Generator/index.html#type-t">Base_quickcheck.Generator.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-quickcheck_observer" class="anchored"><a href="#val-quickcheck_observer" class="anchor"></a><code><span><span class="keyword">val</span> quickcheck_observer : <span><a href="#type-t">t</a> <a href="../../../base_quickcheck/Base_quickcheck/Observer/index.html#type-t">Base_quickcheck.Observer.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-quickcheck_shrinker" class="anchored"><a href="#val-quickcheck_shrinker" class="anchor"></a><code><span><span class="keyword">val</span> quickcheck_shrinker : <span><a href="#type-t">t</a> <a href="../../../base_quickcheck/Base_quickcheck/Shrinker/index.html#type-t">Base_quickcheck.Shrinker.t</a></span></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../../../sexplib/Sexplib/Sexp/index.html">Sexplib.Sexp</a> <span class="keyword">end</span> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../sexplib/Sexplib/Sexp/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../sexplib/Sexplib/Sexp_intf/module-type-S/index.html">Sexplib.Sexp_intf.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../sexplib/Sexplib/Sexp_intf/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-bigstring" class="anchored"><a href="#type-bigstring" class="anchor"></a><code><span><span class="keyword">type</span> bigstring</span><span> =
  <span><span>( char, <span class="xref-unresolved">Stdlib</span>.Bigarray.int8_unsigned_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout )</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span></span></code></div><div class="spec-doc"><p>Type of bigstrings</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><h6 id="defaults"><a href="#defaults" class="anchor"></a>Defaults</h6><div class="odoc-spec"><div class="spec value" id="val-default_indent" class="anchored"><a href="#val-default_indent" class="anchor"></a><code><span><span class="keyword">val</span> default_indent : <span>int <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p><code>default_indent</code> reference to default indentation level for human-readable conversions. Initialisation value: 2.</p></div></div><h6 id="s-expression-size"><a href="#s-expression-size" class="anchor"></a>S-expression size</h6><div class="odoc-spec"><div class="spec value" id="val-size" class="anchored"><a href="#val-size" class="anchor"></a><code><span><span class="keyword">val</span> size : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>size sexp</code> </p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>(n_atoms, n_chars)</code>, where <code>n_atoms</code> is the number of atoms in S-expression <code>sexp</code>, and <code>n_chars</code> is the number of characters in the atoms of the S-expression.</p></li></ul></div></div><h6 id="scan-functions"><a href="#scan-functions" class="anchor"></a>Scan functions</h6><div class="odoc-spec"><div class="spec value" id="val-scan_sexp" class="anchored"><a href="#val-scan_sexp" class="anchor"></a><code><span><span class="keyword">val</span> scan_sexp : <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>scan_sexp ?buf lexbuf</code> scans an S-expression from lex buffer <code>lexbuf</code> using the optional string buffer <code>buf</code> for storing intermediate strings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_sexps" class="anchored"><a href="#val-scan_sexps" class="anchor"></a><code><span><span class="keyword">val</span> scan_sexps : <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>scan_sexps ?buf lexbuf</code> reads a list of S-expressions from lex buffer <code>lexbuf</code> using the optional string buffer <code>buf</code> for storing intermediate strings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_rev_sexps" class="anchored"><a href="#val-scan_rev_sexps" class="anchor"></a><code><span><span class="keyword">val</span> scan_rev_sexps : <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>scan_rev_sexps ?buf lexbuf</code> same as <a href="#val-scan_sexps"><code>scan_sexps</code></a>, but returns the reversed list and is slightly more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_sexp_opt" class="anchored"><a href="#val-scan_sexp_opt" class="anchor"></a><code><span><span class="keyword">val</span> scan_sexp_opt : <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>scan_sexp_opt ?buf lexbuf</code> is equivalent to <code>scan_sexp ?buf lexbuf</code> except that it returns <code>None</code> when the eof is reached.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_iter_sexps" class="anchored"><a href="#val-scan_iter_sexps" class="anchor"></a><code><span><span class="keyword">val</span> scan_iter_sexps : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>scan_iter_sexps ?buf ~f lexbuf</code> iterates over all S-expressions scanned from lex buffer <code>lexbuf</code> using function <code>f</code>, and the optional string buffer <code>buf</code> for storing intermediate strings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_fold_sexps" class="anchored"><a href="#val-scan_fold_sexps" class="anchor"></a><code><span><span class="keyword">val</span> scan_fold_sexps : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>scan_fold_sexps ?buf ~f ~init lexbuf</code> folds over all S-expressions scanned from lex buffer <code>lexbuf</code> using function <code>f</code>, initial state <code>init</code>, and the optional string buffer <code>buf</code> for storing intermediate strings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_sexps_conv" class="anchored"><a href="#val-scan_sexps_conv" class="anchor"></a><code><span><span class="keyword">val</span> scan_sexps_conv : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>scan_sexps_conv ?buf ~f lexbuf</code> maps all S-expressions scanned from lex buffer <code>lexbuf</code> to some list using function <code>f</code>, and the optional string buffer <code>buf</code> for storing intermediate strings.</p></div></div><h6 id="type-and-exception-definitions-for-(partial)-parsing"><a href="#type-and-exception-definitions-for-(partial)-parsing" class="anchor"></a>Type and exception definitions for (partial) parsing</h6><div class="odoc-spec"><div class="spec module" id="module-Parse_pos" class="anchored"><a href="#module-Parse_pos" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Parse_pos/index.html">Parse_pos</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Cont_state" class="anchored"><a href="#module-Cont_state" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cont_state/index.html">Cont_state</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-parse_result" class="anchored"><a href="#type-parse_result" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 't) parse_result</span></span><span> = <span><span>( <span class="type-var">'a</span>, <span class="type-var">'t</span> )</span> <a href="../../../sexplib/Sexplib/Pre_sexp/index.html#type-parse_result">Sexplib.Pre_sexp.parse_result</a></span></span><span> = </span></code><table><tr id="type-parse_result.Done" class="anchored"><td class="def variant constructor"><a href="#type-parse_result.Done" class="anchor"></a><code><span>| </span><span><span class="constructor">Done</span> <span class="keyword">of</span> <span class="type-var">'t</span> * <a href="Parse_pos/index.html#type-t">Parse_pos.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Done (t, parse_pos)</code> finished parsing an S-expression. Current parse position is <code>parse_pos</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-parse_result.Cont" class="anchored"><td class="def variant constructor"><a href="#type-parse_result.Cont" class="anchor"></a><code><span>| </span><span><span class="constructor">Cont</span> <span class="keyword">of</span> <a href="Cont_state/index.html#type-t">Cont_state.t</a> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'t</span> )</span> <a href="#type-parse_fun">parse_fun</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Cont (cont_state, parse_fun)</code> met the end of input before completely parsing an S-expression. The user has to call <code>parse_fun</code> to continue parsing the S-expression in another buffer. <code>cont_state</code> is the current parsing state of the continuation. NOTE: the continuation may only be called once and will raise <code>Failure</code> otherwise!</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Type of result from calling <a href="#val-parse"><code>Sexp.parse</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-parse_fun" class="anchored"><a href="#type-parse_fun" class="anchor"></a><code><span><span class="keyword">and</span> <span>('a, 't) parse_fun</span></span><span> = <span>pos:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'t</span> )</span> <a href="#type-parse_result">parse_result</a></span></span></code></div><div class="spec-doc"><p>Type of parsing functions with given offsets and lengths.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Annotated" class="anchored"><a href="#module-Annotated" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Annotated/index.html">Annotated</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module for parsing S-expressions annotated with location information</p></div></div><div class="odoc-spec"><div class="spec type" id="type-parse_state" class="anchored"><a href="#type-parse_state" class="anchor"></a><code><span><span class="keyword">type</span> <span>'t parse_state</span></span><span> = <span class="keyword">private</span> <span><span class="type-var">'t</span> <a href="../../../sexplib/Sexplib/Pre_sexp/index.html#type-parse_state">Sexplib.Pre_sexp.parse_state</a></span></span><span> = </span><span>{</span></code><table><tr id="type-parse_state.parse_pos" class="anchored"><td class="def record field"><a href="#type-parse_state.parse_pos" class="anchor"></a><code><span>parse_pos : <a href="Parse_pos/index.html#type-t">Parse_pos.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Current parse position</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Type of state maintained during parsing</p></div></div><div class="odoc-spec"><div class="spec type" id="type-parse_error" class="anchored"><a href="#type-parse_error" class="anchor"></a><code><span><span class="keyword">type</span> parse_error</span><span> = <a href="../../../sexplib/Sexplib/Pre_sexp/index.html#type-parse_error">Sexplib.Pre_sexp.parse_error</a></span><span> = </span><span>{</span></code><table><tr id="type-parse_error.err_msg" class="anchored"><td class="def record field"><a href="#type-parse_error.err_msg" class="anchor"></a><code><span>err_msg : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Reason why parsing failed</p><span class="comment-delim">*)</span></td></tr><tr id="type-parse_error.parse_state" class="anchored"><td class="def record field"><a href="#type-parse_error.parse_state" class="anchor"></a><code><span>parse_state : <span>[ <span>`Sexp of <span><span><span><a href="#type-t">t</a> list</span> list</span> <a href="#type-parse_state">parse_state</a></span></span>
              <span><span>| `Annot</span> of <span><a href="Annotated/index.html#type-stack">Annotated.stack</a> <a href="#type-parse_state">parse_state</a></span></span> ]</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>State of parser</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Type of parse errors</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Parse_error" class="anchored"><a href="#exception-Parse_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Parse_error</span> <span class="keyword">of</span> <a href="#type-parse_error">parse_error</a></span></code></div><div class="spec-doc"><p>Exception raised during partial parsing</p></div></div><h6 id="unannotated-(partial)-parsing"><a href="#unannotated-(partial)-parsing" class="anchor"></a>Unannotated (partial) parsing</h6><div class="odoc-spec"><div class="spec value" id="val-parse" class="anchored"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : 
  <span>?parse_pos:<a href="Parse_pos/index.html#type-t">Parse_pos.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( string, <a href="#type-t">t</a> )</span> <a href="#type-parse_result">parse_result</a></span></span></code></div><div class="spec-doc"><p><code>parse ?parse_pos ?len str</code> (partially) parses an S-expression in string buffer <code>str</code> starting out with position information provided in <code>parse_pos</code> and reading at most <code>len</code> characters. To parse a single atom that is not delimited by whitespace it is necessary to call this function a second time with the returned continuation, and a dummy buffer that contains whitespace.</p><p><code>parse</code> starts parsing <code>str</code> at position <code>parse_pos.buf_pos</code>. Each subsequent <code>parse_fun</code> from a <code>Cont</code> uses the <code>buf</code> and <code>pos</code> that is supplied to it. The final <code>parse_fun</code> that returns <code>Done</code> mutates the <code>buf_pos</code> in the originally supplied <code>parse_pos</code>, and then returns it.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">parse_pos</span> <p>default = <code>Parse_pos.create ()</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">len</span> <p>default = <code>String.length str - parse_pos.Parse_pos.buf_pos</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-parse_bigstring" class="anchored"><a href="#val-parse_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> parse_bigstring : 
  <span>?parse_pos:<a href="Parse_pos/index.html#type-t">Parse_pos.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <a href="#type-bigstring">bigstring</a>, <a href="#type-t">t</a> )</span> <a href="#type-parse_result">parse_result</a></span></span></code></div><div class="spec-doc"><p><code>parse_bigstring ?parse_pos ?len str</code> same as <a href="#val-parse"><code>parse</code></a>, but operates on bigstrings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-input_sexp" class="anchored"><a href="#val-input_sexp" class="anchor"></a><code><span><span class="keyword">val</span> input_sexp : <span>?parse_pos:<a href="Parse_pos/index.html#type-t">Parse_pos.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>input_sexp ?parse_pos ic</code> parses an S-expression from input channel <code>ic</code> using initial position information in <code>parse_pos</code>. NOTE: this function is not as fast on files as <a href="#val-load_sexp"><code>Sexp.load_sexp</code></a>, and is also slightly slower than the scan-functions. But it is guaranteed that <code>input_sexp</code> is only going to read data parseable as an S-expression. Thus, subsequent input functions will see the data immediately following it.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">parse_pos</span> <p>default = <code>Parse_pos.create ()</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-input_sexps" class="anchored"><a href="#val-input_sexps" class="anchor"></a><code><span><span class="keyword">val</span> input_sexps : 
  <span>?parse_pos:<a href="Parse_pos/index.html#type-t">Parse_pos.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>input_sexps ?parse_pos ?buf ic</code> parses S-expressions from input channel <code>ic</code> until EOF is reached. Faster than the scan-functions.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">parse_pos</span> <p>default = <code>Parse_pos.create ()</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-input_rev_sexps" class="anchored"><a href="#val-input_rev_sexps" class="anchor"></a><code><span><span class="keyword">val</span> input_rev_sexps : 
  <span>?parse_pos:<a href="Parse_pos/index.html#type-t">Parse_pos.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>input_rev_sexps ?parse_pos ?buf ic</code> same as <a href="#val-input_sexps"><code>Sexp.input_sexps</code></a>, but returns a reversed list of S-expressions, which is slightly more efficient.</p></div></div><h6 id="loading-of-(converted)-s-expressions"><a href="#loading-of-(converted)-s-expressions" class="anchor"></a>Loading of (converted) S-expressions</h6><div class="odoc-spec"><div class="spec value" id="val-load_sexp" class="anchored"><a href="#val-load_sexp" class="anchor"></a><code><span><span class="keyword">val</span> load_sexp : <span>?strict:bool <span class="arrow">&#45;&gt;</span></span> <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>load_sexp ?strict ?buf file</code> reads one S-expression from <code>file</code> using buffer <code>buf</code> for storing intermediate data. Faster than the scan-functions.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Parse_error</span> <p>if the S-expression is unparseable.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if parsing reached the end of file before one S-expression could be read.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if <code>strict</code> is true and there is more than one S-expression in the file.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">strict</span> <p>default = <code>true</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexps" class="anchored"><a href="#val-load_sexps" class="anchor"></a><code><span><span class="keyword">val</span> load_sexps : <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>load_sexps ?buf file</code> reads a list of S-expressions from <code>file</code> using buffer <code>buf</code> for storing intermediate data. Faster than the scan-functions.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Parse_error</span> <p>if there is unparseable data in the file.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if parsing reached the end of file before the last S-expression could be fully read.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-load_rev_sexps" class="anchored"><a href="#val-load_rev_sexps" class="anchor"></a><code><span><span class="keyword">val</span> load_rev_sexps : <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>load_rev_sexps ?buf file</code> same as <a href="#val-load_sexps"><code>Sexp.load_sexps</code></a>, but returns a reversed list of S-expressions, which is slightly more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexp_conv" class="anchored"><a href="#val-load_sexp_conv" class="anchor"></a><code><span><span class="keyword">val</span> load_sexp_conv : 
  <span>?strict:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="Annotated/index.html#type-conv">Annotated.conv</a></span></span></code></div><div class="spec-doc"><p><code>load_sexp_conv ?strict ?buf file f</code> like <a href="#val-load_sexp"><code>Sexp.load_sexp</code></a>, but performs a conversion on the fly using <code>f</code>. Performance is equivalent to executing <a href="#val-load_sexp"><code>Sexp.load_sexp</code></a> and performing conversion when there are no errors. In contrast to the plain S-expression loader, this function not only performs the conversion, it will give exact error ranges for conversion errors.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Parse_error</span> <p>if there is unparseable data in the file.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if parsing reached the end of file before the last S-expression could be fully read.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexp_conv_exn" class="anchored"><a href="#val-load_sexp_conv_exn" class="anchor"></a><code><span><span class="keyword">val</span> load_sexp_conv_exn : 
  <span>?strict:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>load_sexp_conv_exn ?strict ?buf file f</code> like <a href="#val-load_sexp_conv"><code>load_sexp_conv</code></a>, but returns the converted value or raises <code>Of_sexp_error</code> with exact location information in the case of a conversion error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexps_conv" class="anchored"><a href="#val-load_sexps_conv" class="anchor"></a><code><span><span class="keyword">val</span> load_sexps_conv : 
  <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="Annotated/index.html#type-conv">Annotated.conv</a></span> list</span></span></code></div><div class="spec-doc"><p><code>load_sexps_conv ?buf file f</code> like <a href="#val-load_sexps"><code>Sexp.load_sexps</code></a>, but performs a conversion on the fly using <code>f</code>. Performance is equivalent to executing <a href="#val-load_sexps"><code>Sexp.load_sexps</code></a> and performing conversion when there are no errors. In contrast to the plain S-expression loader, this function not only performs the conversion, it will give exact error ranges for conversion errors.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Parse_error</span> <p>if there is unparseable data in the file.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if parsing reached the end of file before the last S-expression could be fully read.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexps_conv_exn" class="anchored"><a href="#val-load_sexps_conv_exn" class="anchor"></a><code><span><span class="keyword">val</span> load_sexps_conv_exn : <span>?buf:bytes <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>load_sexps_conv_exn ?buf file f</code> like <a href="#val-load_sexps_conv"><code>load_sexps_conv</code></a>, but returns the converted value or raises <code>Of_sexp_error</code> with exact location information in the case of a conversion error.</p></div></div><h6 id="output-of-s-expressions-to-i/o-channels"><a href="#output-of-s-expressions-to-i/o-channels" class="anchor"></a>Output of S-expressions to I/O-channels</h6><p>NOTE: for performance reasons these output functions may need to allocate large strings to write out huge S-expressions. This may cause problems on 32-bit platforms. If you think that you may need to write huge S-expressions on such platforms, you might want to use the pretty-printers that write to formatters instead (see further below).</p><div class="odoc-spec"><div class="spec value" id="val-output_hum" class="anchored"><a href="#val-output_hum" class="anchor"></a><code><span><span class="keyword">val</span> output_hum : <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output_hum oc sexp</code> outputs S-expression <code>sexp</code> to output channel <code>oc</code> in human readable form.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-output_hum_indent" class="anchored"><a href="#val-output_hum_indent" class="anchor"></a><code><span><span class="keyword">val</span> output_hum_indent : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output_hum_indent indent oc sexp</code> outputs S-expression <code>sexp</code> to output channel <code>oc</code> in human readable form using indentation level <code>indent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-output_mach" class="anchored"><a href="#val-output_mach" class="anchor"></a><code><span><span class="keyword">val</span> output_mach : <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output_mach oc sexp</code> outputs S-expression <code>sexp</code> to output channel <code>oc</code> in machine readable (i.e. most compact) form.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-output" class="anchored"><a href="#val-output" class="anchor"></a><code><span><span class="keyword">val</span> output : <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output oc sexp</code> same as <code>output_mach</code>.</p></div></div><h6 id="output-of-s-expressions-to-file"><a href="#output-of-s-expressions-to-file" class="anchor"></a>Output of S-expressions to file</h6><p>All save-functions write to a temporary file before moving it into place to avoid intermittent garbling of existing files, which may cause problems for other processes that try to read.</p><div class="odoc-spec"><div class="spec value" id="val-save_hum" class="anchored"><a href="#val-save_hum" class="anchor"></a><code><span><span class="keyword">val</span> save_hum : <span>?perm:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>save_hum ?perm file sexp</code> outputs S-expression <code>sexp</code> to <code>file</code> in human readable form.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">perm</span> <p>default = umask</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-save_mach" class="anchored"><a href="#val-save_mach" class="anchor"></a><code><span><span class="keyword">val</span> save_mach : <span>?perm:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>save_mach ?perm file sexp</code> outputs S-expression <code>sexp</code> to <code>file</code> in machine readable (i.e. most compact) form.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">perm</span> <p>default = umask</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-save" class="anchored"><a href="#val-save" class="anchor"></a><code><span><span class="keyword">val</span> save : <span>?perm:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>save ?perm file sexp</code> same as <a href="#val-save_mach"><code>save_mach</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-save_sexps_hum" class="anchored"><a href="#val-save_sexps_hum" class="anchor"></a><code><span><span class="keyword">val</span> save_sexps_hum : <span>?perm:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>save_sexps_hum ?perm file sexps</code> outputs S-expression list <code>sexps</code> to <code>file</code> in human readable form, each sexp being followed by a newline.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">perm</span> <p>default = umask</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-save_sexps_mach" class="anchored"><a href="#val-save_sexps_mach" class="anchor"></a><code><span><span class="keyword">val</span> save_sexps_mach : <span>?perm:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>save_sexps_mach ?perm file sexps</code> outputs S-expression list <code>sexps</code> to <code>file</code> in machine readable form, each sexp being followed by a newline.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">perm</span> <p>default = umask</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-save_sexps" class="anchored"><a href="#val-save_sexps" class="anchor"></a><code><span><span class="keyword">val</span> save_sexps : <span>?perm:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>save_sexps ?perm file sexp</code> same as <a href="#val-save_sexps_mach"><code>save_sexps_mach</code></a>.</p></div></div><h6 id="output-of-s-expressions-to-formatters"><a href="#output-of-s-expressions-to-formatters" class="anchor"></a>Output of S-expressions to formatters</h6><div class="odoc-spec"><div class="spec value" id="val-pp_hum" class="anchored"><a href="#val-pp_hum" class="anchor"></a><code><span><span class="keyword">val</span> pp_hum : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_hum ppf sexp</code> outputs S-expression <code>sexp</code> to formatter <code>ppf</code> in human readable form.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_hum_indent" class="anchored"><a href="#val-pp_hum_indent" class="anchor"></a><code><span><span class="keyword">val</span> pp_hum_indent : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_hum_indent n ppf sexp</code> outputs S-expression <code>sexp</code> to formatter <code>ppf</code> in human readable form and indentation level <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_mach" class="anchored"><a href="#val-pp_mach" class="anchor"></a><code><span><span class="keyword">val</span> pp_mach : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_mach ppf sexp</code> outputs S-expression <code>sexp</code> to formatter <code>ppf</code> in machine readable (i.e. most compact) form.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp ppf sexp</code> same as <code>pp_mach</code>.</p></div></div><h6 id="string-and-bigstring-conversions_2"><a href="#string-and-bigstring-conversions_2" class="anchor"></a>String and bigstring conversions</h6><div class="odoc-spec"><div class="spec module" id="module-Of_string_conv_exn" class="anchored"><a href="#module-Of_string_conv_exn" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Of_string_conv_exn/index.html">Of_string_conv_exn</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module encapsulating the exception raised by string converters when type conversions fail.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string str</code> parses a string <code>str</code> as an S-expression.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string_many" class="anchored"><a href="#val-of_string_many" class="anchor"></a><code><span><span class="keyword">val</span> of_string_many : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>of_string_many</code> parses a string containing zero or more S-expressions.</p><p>Unlike many other functions in this module, on parse failure it raises <code>Parsexp.Parse_error</code> rather than a native <code>Sexplib.Sexp.Parse_error</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string_conv" class="anchored"><a href="#val-of_string_conv" class="anchor"></a><code><span><span class="keyword">val</span> of_string_conv : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="Annotated/index.html#type-conv">Annotated.conv</a></span></span></code></div><div class="spec-doc"><p><code>of_string_conv str conv</code> like <a href="#val-of_string"><code>of_string</code></a>, but performs type conversion with <code>conv</code>. </p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>conversion result.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string_many_conv_exn" class="anchored"><a href="#val-of_string_many_conv_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_string_many_conv_exn : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>of_string_many_conv_exn str conv</code> like <a href="#val-of_string_many"><code>of_string_many</code></a>, but performs type conversion with <code>conv</code>. Raises if type conversion fails.</p><p>Unlike many other functions in this module, on parse failure it raises <code>Parsexp.Parse_error</code> rather than a native <code>Sexplib.Sexp.Parse_error</code>.</p><p>It still raises <code>Sexplib.Sexp.Of_string_conv_exn</code> on sexp conversion errors.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>conversion result.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string_conv_exn" class="anchored"><a href="#val-of_string_conv_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_string_conv_exn : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>of_string_conv_exn str conv</code> like <a href="#val-of_string_conv"><code>of_string_conv</code></a>, but raises <a href="Of_string_conv_exn/index.html#exception-E"><code>Of_string_conv_exn.E</code></a> if type conversion fails. </p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>converted value.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bigstring" class="anchored"><a href="#val-of_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> of_bigstring : <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bigstring bstr</code> same as <a href="#val-of_string"><code>of_string</code></a>, but operates on bigstrings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bigstring_conv" class="anchored"><a href="#val-of_bigstring_conv" class="anchor"></a><code><span><span class="keyword">val</span> of_bigstring_conv : <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="Annotated/index.html#type-conv">Annotated.conv</a></span></span></code></div><div class="spec-doc"><p><code>of_bigstring_conv bstr conv</code> like <a href="#val-of_bigstring"><code>of_bigstring</code></a>, but performs type conversion with <code>conv</code>. </p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>conversion result.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bigstring_conv_exn" class="anchored"><a href="#val-of_bigstring_conv_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_bigstring_conv_exn : <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>of_bigstring_conv_exn bstr conv</code> like <a href="#val-of_bigstring_conv"><code>of_bigstring_conv</code></a>, but raises <a href="Of_string_conv_exn/index.html#exception-E"><code>Of_string_conv_exn.E</code></a> if type conversion fails. </p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>converted value.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string_hum" class="anchored"><a href="#val-to_string_hum" class="anchor"></a><code><span><span class="keyword">val</span> to_string_hum : <span>?indent:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string_hum ?indent sexp</code> converts S-expression <code>sexp</code> to a string in human readable form with indentation level <code>indent</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">indent</span> <p>default = <code>!default_indent</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string_mach" class="anchored"><a href="#val-to_string_mach" class="anchor"></a><code><span><span class="keyword">val</span> to_string_mach : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string_mach sexp</code> converts S-expression <code>sexp</code> to a string in machine readable (i.e. most compact) form.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string sexp</code> same as <code>to_string_mach</code>.</p></div></div><h6 id="buffer-conversions"><a href="#buffer-conversions" class="anchor"></a>Buffer conversions</h6><div class="odoc-spec"><div class="spec value" id="val-to_buffer_hum" class="anchored"><a href="#val-to_buffer_hum" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer_hum : <span>buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span>?indent:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>to_buffer_hum ~buf ?indent sexp</code> outputs the S-expression <code>sexp</code> converted to a string in human readable form to buffer <code>buf</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">indent</span> <p>default = <code>!default_indent</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_buffer_mach" class="anchored"><a href="#val-to_buffer_mach" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer_mach : <span>buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>to_buffer_mach ~buf sexp</code> outputs the S-expression <code>sexp</code> converted to a string in machine readable (i.e. most compact) form to buffer <code>buf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_buffer" class="anchored"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span>buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>to_buffer ~buf sexp</code> same as <a href="#val-to_buffer_mach"><code>to_buffer_mach</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_buffer_gen" class="anchored"><a href="#val-to_buffer_gen" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer_gen : 
  <span>buf:<span class="type-var">'buffer</span> <span class="arrow">&#45;&gt;</span></span>
  <span>add_char:<span>( <span><span class="type-var">'buffer</span> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>add_string:<span>( <span><span class="type-var">'buffer</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>to_buffer_gen ~buf ~add_char ~add_string sexp</code> outputs the S-expression <code>sexp</code> converted to a string to buffer <code>buf</code> using the output functions <code>add_char</code> and <code>add_string</code>.</p></div></div><h6 id="utilities-for-automated-type-conversions"><a href="#utilities-for-automated-type-conversions" class="anchor"></a>Utilities for automated type conversions</h6><div class="odoc-spec"><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span><span class="keyword">val</span> unit : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>unit</code> the unit-value as expressed by an S-expression.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_unit" class="anchored"><a href="#val-is_unit" class="anchor"></a><code><span><span class="keyword">val</span> is_unit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sexp_of_t sexp</code> maps S-expressions which are part of a type with automated S-expression conversion to themselves.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-t_of_sexp" class="anchored"><a href="#val-t_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> t_of_sexp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>t_of_sexp sexp</code> maps S-expressions which are part of a type with automated S-expression conversion to themselves.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-t_sexp_grammar" class="anchored"><a href="#val-t_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> t_sexp_grammar : <span><a href="#type-t">t</a> <span class="xref-unresolved">Sexplib0</span>.Sexp_grammar.t</span></span></code></div></div><h6 id="utilities-for-conversion-error-handling"><a href="#utilities-for-conversion-error-handling" class="anchor"></a>Utilities for conversion error handling</h6><div class="odoc-spec"><div class="spec type" id="type-found" class="anchored"><a href="#type-found" class="anchor"></a><code><span><span class="keyword">type</span> found</span><span> = </span><span>[ </span></code><table><tr id="type-found.Found" class="anchored"><td class="def constructor"><a href="#type-found.Found" class="anchor"></a><code><span>| </span></code><code><span>`Found</span></code></td></tr><tr id="type-found.Pos" class="anchored"><td class="def constructor"><a href="#type-found.Pos" class="anchor"></a><code><span>| </span></code><code><span>`Pos <span class="keyword">of</span> int * <a href="#type-found">found</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Type of successful search results. <code>`Found</code> means that an S-expression was found at the immediate position, and <code>`Pos (pos,
      found)</code> indicates that it was found at position <code>pos</code> within a structure (= S-expression list) where <code>found</code> describes recursively where it was found in that structure.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-search_result" class="anchored"><a href="#type-search_result" class="anchor"></a><code><span><span class="keyword">type</span> search_result</span><span> = </span><span>[ </span></code><table><tr id="type-search_result.Not_found" class="anchored"><td class="def constructor"><a href="#type-search_result.Not_found" class="anchor"></a><code><span>| </span></code><code><span>`Not_found</span></code></td></tr><tr id="type-search_result.found" class="anchored"><td class="def type"><a href="#type-search_result.found" class="anchor"></a><code><span>| </span></code><code><span><a href="#type-found">found</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Type of search results. <code>`Not_found</code> means that an S-expression was not found within another S-expression.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-search_physical" class="anchored"><a href="#val-search_physical" class="anchor"></a><code><span><span class="keyword">val</span> search_physical : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>contained:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-search_result">search_result</a></span></code></div><div class="spec-doc"><p><code>search_physical sexp ~contained</code> </p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the search result indicating whether, and if, where the S-expression <code>contained</code> was found within S-expression <code>sexp</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_found" class="anchored"><a href="#val-subst_found" class="anchor"></a><code><span><span class="keyword">val</span> subst_found : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>subst:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-found">found</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>subst_found sexp ~subst found</code> </p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the S-expression that results from substituting <code>subst</code> within S-expression <code>sexp</code> at the location described by <code>found</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec module" id="module-With_layout" class="anchored"><a href="#module-With_layout" class="anchor"></a><code><span><span class="keyword">module</span> <a href="With_layout/index.html">With_layout</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>S-expressions annotated with relative source positions and comments</p></div></div></details></div></details></div><div class="odoc-spec"><div class="spec exception" id="exception-Of_sexp_error" class="anchored"><a href="#exception-Of_sexp_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Of_sexp_error</span> <span class="keyword">of</span> <a href="../../../base/Base/Exn/index.html#type-t">Base.Exn.t</a> * <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_float_style" class="anchored"><a href="#val-of_float_style" class="anchor"></a><code><span><span class="keyword">val</span> of_float_style : <span><span>[ `Underscores <span>| `No_underscores</span> ]</span> <a href="../../../base/Base/Ref/index.html#type-t">Base.Ref.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_int_style" class="anchored"><a href="#val-of_int_style" class="anchor"></a><code><span><span class="keyword">val</span> of_int_style : <span><span>[ `Underscores <span>| `No_underscores</span> ]</span> <a href="../../../base/Base/Ref/index.html#type-t">Base.Ref.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-no_raise" class="anchored"><a href="#type-no_raise" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a no_raise</span></span><span> = <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>no_raise</code> is the identity, but by using <code>'a no_raise</code> in a sexpable type, the resulting use <code>sexp_of_no_raise</code> protects the conversion of <code>'a</code> to a sexp so that if it fails, one gets a sexp with an error message about the failure, rather than an exception being raised.</p><p>WARNING: The resulting <code>no_raise_of_sexp</code> can still raise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_shape_no_raise" class="anchored"><a href="#val-bin_shape_no_raise" class="anchor"></a><code><span><span class="keyword">val</span> bin_shape_no_raise : <span><a href="../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_size_no_raise" class="anchored"><a href="#val-bin_size_no_raise" class="anchor"></a><code><span><span class="keyword">val</span> bin_size_no_raise : 
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span> <a href="../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_write_no_raise" class="anchored"><a href="#val-bin_write_no_raise" class="anchor"></a><code><span><span class="keyword">val</span> bin_write_no_raise : 
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span> <a href="../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_writer_no_raise" class="anchored"><a href="#val-bin_writer_no_raise" class="anchor"></a><code><span><span class="keyword">val</span> bin_writer_no_raise : 
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_read_no_raise" class="anchored"><a href="#val-bin_read_no_raise" class="anchor"></a><code><span><span class="keyword">val</span> bin_read_no_raise : 
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span> <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-__bin_read_no_raise__" class="anchored"><a href="#val-__bin_read_no_raise__" class="anchor"></a><code><span><span class="keyword">val</span> __bin_read_no_raise__ : 
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span> )</span> <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_reader_no_raise" class="anchored"><a href="#val-bin_reader_no_raise" class="anchor"></a><code><span><span class="keyword">val</span> bin_reader_no_raise : 
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_no_raise" class="anchored"><a href="#val-bin_no_raise" class="anchor"></a><code><span><span class="keyword">val</span> bin_no_raise : 
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_no_raise" class="anchored"><a href="#val-sexp_of_no_raise" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_no_raise : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-no_raise_of_sexp" class="anchored"><a href="#val-no_raise_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> no_raise_of_sexp : 
  <span><span>( <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-no_raise">no_raise</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Sexp_maybe" class="anchored"><a href="#module-Sexp_maybe" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sexp_maybe/index.html">Sexp_maybe</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>If <code>sexp_of_t fails</code>, it returns <code>Error</code> rather than raising. You can convert values of this type to and from sexp in processes that can or cannot parse the underlying sexp in any combination and still recover the original value. Also, the <code>Error</code> case contains a human-readable description of the error.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-With_text" class="anchored"><a href="#module-With_text" class="anchor"></a><code><span><span class="keyword">module</span> <a href="With_text/index.html">With_text</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A <code>With_text.t</code> is a value paired with the full textual representation of its sexp. This is useful for dealing with the case where you want to keep track of a value along with the format of the s-expression it was generated from, which allows you to maintain formatting details, comments, etc.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_sexp_allow_extra_fields_recursively" class="anchored"><a href="#val-of_sexp_allow_extra_fields_recursively" class="anchor"></a><code><span><span class="keyword">val</span> of_sexp_allow_extra_fields_recursively : 
  <span><span>( <span><a href="../../../base/Base/Sexp/index.html#type-t">Base.Sexp.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../base/Base/Sexp/index.html#type-t">Base.Sexp.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>of_sexp_allow_extra_fields_recursively of_sexp sexp</code> uses <code>of_sexp</code> to convert <code>sexp</code> to a value, but will not fail if there are any extra fields in a record (even deeply nested records).</p><p>The implementation uses global state, so it is not thread safe.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Stable" class="anchored"><a href="#module-Stable" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Stable/index.html">Stable</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>