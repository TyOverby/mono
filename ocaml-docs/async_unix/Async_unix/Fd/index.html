<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fd (async_unix.Async_unix.Fd)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Fd</nav><header class="odoc-preamble"><h1>Module <code><span>Async_unix.Fd</span></code></h1><p>An <code>Fd.t</code> is a wrapper around a Unix file descriptor, with additional information about the kind of file descriptor and logic to ensure that we don't use a file descriptor that has been closed, or close a file descriptor that is in use.</p><p>Since Async uses multiple threads to make read/write and other system calls on file descriptors, and Unix reuses descriptors after they are closed, Async has to be very careful that the file descriptor passed to a system call is referring to the file it intends, and not some other completely unrelated file that Unix has decided to assign to the same descriptor.</p><p>Provided that one only accesses a file descriptor within the context of the functions below, <code>Fd</code> guarantees that the file descriptor will not have been closed/reused and will correspond to the same file that it did when the <code>Fd.t</code> was created:</p><pre>      with_file_descr
      with_file_descr_deferred
      syscall
      syscall_exn
      syscall_result_exn
      syscall_in_thread
      syscall_in_thread_exn</pre><p>The <code>Fd</code> module keeps track of which of these functions are currently accessing the file descriptor, and ensures that any close happens after they complete. Also, once close has been called, it refuses to provide further access to the file descriptor, either by returning a variant <code>`Already_closed</code> or by raising an exception.</p><p>Some of the above functions take an optional <code>?nonblocking:bool</code> argument. The default is <code>false</code>, but if it is set to <code>true</code>, then before supplying the underlying <code>file_descr</code>, the <code>Fd</code> module will first call <code>Unix.set_nonblock file_descr</code>, if it hasn't previously done so on that file descriptor. This is intended to support making nonblocking system calls (e.g., connect, read, write) directly within Async, without releasing the OCaml lock or the Async lock, and without using another thread.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Kind" class="anchored"><a href="#module-Kind" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Kind/index.html">Kind</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t_hum" class="anchored"><a href="#type-t_hum" class="anchor"></a><code><span><span class="keyword">type</span> t_hum</span><span> = <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t_hum" class="anchored"><a href="#val-sexp_of_t_hum" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t_hum : <span><a href="#type-t_hum">t_hum</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-info" class="anchored"><a href="#val-info" class="anchor"></a><code><span><span class="keyword">val</span> info : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../core/Core/Info/index.html#type-t">Core.Info.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string t</code> returns a pretty sexp of the representation of <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span>?avoid_setting_nonblock:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Kind/index.html#type-t">Kind.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create ?support_nonblock kind file_descr</code> creates a new <code>t</code> of the underlying kind and file descriptor.</p><p>We thought about using <code>fstat()</code> rather than requiring the user to supply the kind. But <code>fstat</code> can block, which would require putting this in a thread, which has some consequences, and it isn't clear that it gets us that much. Also, <code>create</code> is mostly used within the Async implementation -- clients shouldn't need it unless they are mixing Async and non-Async code.</p><p>If <code>avoid_setting_nonblock</code>, then Async will not set nonblock flag on the file descriptor. The fd will be used in accordance with the existing flag.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_borrowed" class="anchored"><a href="#val-create_borrowed" class="anchor"></a><code><span><span class="keyword">val</span> create_borrowed : 
  <span>?avoid_setting_nonblock:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Kind/index.html#type-t">Kind.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>create_borrowed kind descr info ~f</code> borrows a file descriptor that is not managed by Async, creates an <code>Fd.t</code> (see <code>create</code>), and runs <code>f</code> that uses that fd in async.</p><p>After <code>f</code> is finished (or raises an exception), it returns the file descriptor to its original owner (leaving <code>Fd.t</code> in a closed state, but not closing <code>descr</code>).</p><p>The caller must not close <code>descr</code> while <code>create_borrowed</code> is running.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kind" class="anchored"><a href="#val-kind" class="anchor"></a><code><span><span class="keyword">val</span> kind : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Kind/index.html#type-t">Kind.t</a></span></code></div><div class="spec-doc"><p><code>kind t</code> returns the kind of file descriptor that <code>t</code> is.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-supports_nonblock" class="anchored"><a href="#val-supports_nonblock" class="anchor"></a><code><span><span class="keyword">val</span> supports_nonblock : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>supports_nonblock t</code> returns true if <code>t</code> supports nonblocking system calls.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clear_nonblock" class="anchored"><a href="#val-clear_nonblock" class="anchor"></a><code><span><span class="keyword">val</span> clear_nonblock : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>clear_nonblock t</code> clears the <code>nonblocking</code> flag on <code>t</code> and causes Async to treat the fd as though it doesn't support nonblocking I/O. This is useful for applications that want to share a file descriptor between Async and non-Async code and want to avoid <code>EWOULDBLOCK</code> or <code>EAGAIN</code> being seen by the non-Async code, which would then cause a <code>Sys_blocked_io</code> exception.</p><p><code>clear_nonblock t</code> has no effect if <code>not (supports_nonblock t)</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Close" class="anchored"><a href="#module-Close" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Close/index.html">Close</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The <code>Close</code> module exists to collect <code>close</code> and its associated types, so they can be easily reused elsewhere, e.g., <code>Unix_syscalls</code>.</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Close/index.html">Close</a></span></code></summary><p>The <code>Close</code> module exists to collect <code>close</code> and its associated types, so they can be easily reused elsewhere, e.g., <code>Unix_syscalls</code>.</p><div class="odoc-spec"><div class="spec type" id="type-socket_handling" class="anchored"><a href="#type-socket_handling" class="anchor"></a><code><span><span class="keyword">type</span> socket_handling</span><span> = </span></code><table><tr id="type-socket_handling.Shutdown_socket" class="anchored"><td class="def variant constructor"><a href="#type-socket_handling.Shutdown_socket" class="anchor"></a><code><span>| </span><span><span class="constructor">Shutdown_socket</span></span></code></td></tr><tr id="type-socket_handling.Do_not_shutdown_socket" class="anchored"><td class="def variant constructor"><a href="#type-socket_handling.Do_not_shutdown_socket" class="anchor"></a><code><span>| </span><span><span class="constructor">Do_not_shutdown_socket</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-file_descriptor_handling" class="anchored"><a href="#type-file_descriptor_handling" class="anchor"></a><code><span><span class="keyword">type</span> file_descriptor_handling</span><span> = </span></code><table><tr id="type-file_descriptor_handling.Close_file_descriptor" class="anchored"><td class="def variant constructor"><a href="#type-file_descriptor_handling.Close_file_descriptor" class="anchor"></a><code><span>| </span><span><span class="constructor">Close_file_descriptor</span> <span class="keyword">of</span> <a href="#type-socket_handling">socket_handling</a></span></code></td></tr><tr id="type-file_descriptor_handling.Do_not_close_file_descriptor" class="anchored"><td class="def variant constructor"><a href="#type-file_descriptor_handling.Do_not_close_file_descriptor" class="anchor"></a><code><span>| </span><span><span class="constructor">Do_not_close_file_descriptor</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : 
  <span>?file_descriptor_handling:<a href="#type-file_descriptor_handling">file_descriptor_handling</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>close t</code> prevents further use of <code>t</code>, and makes <code>shutdown()</code> and <code>close()</code> system calls on <code>t</code>'s underlying file descriptor according to the <code>file_descriptor_handling</code> argument and whether or not <code>t</code> is a socket, i.e., <code>kind
      t = Socket `Active</code>:</p><pre>        | file_descriptor_handling                     | shutdown() | close() |
        |----------------------------------------------+------------+---------|
        | Do_not_close_file_descriptor                 | no         | no      |
        | Close_file_descriptor Shutdown_socket        | if socket  | yes     |
        | Close_file_descriptor Do_not_shutdown_socket | no         | yes     |</pre><p>The result of <code>close</code> becomes determined once the system calls complete. It is OK to call <code>close</code> multiple times on the same <code>t</code>; calls subsequent to the initial call will have no effect, but will return the same deferred as the original call.</p></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-close_started" class="anchored"><a href="#val-close_started" class="anchor"></a><code><span><span class="keyword">val</span> close_started : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>close_started t</code> becomes determined when <code>close t</code> is called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close_finished" class="anchored"><a href="#val-close_finished" class="anchor"></a><code><span><span class="keyword">val</span> close_finished : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>close_finished</code> returns the same result as <code>close</code>, but differs in that it does not have the side effect of initiating a close.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_closed" class="anchored"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> has been called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_close" class="anchored"><a href="#val-with_close" class="anchor"></a><code><span><span class="keyword">val</span> with_close : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>with_close t f</code> applies <code>f</code> to <code>t</code>, returns the result of <code>f</code>, and closes <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_open" class="anchored"><a href="#val-is_open" class="anchor"></a><code><span><span class="keyword">val</span> is_open : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_open t</code> is <code>not (is_closed t</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stdin" class="anchored"><a href="#val-stdin" class="anchor"></a><code><span><span class="keyword">val</span> stdin : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>stdin</code>, <code>stdout</code>, and <code>stderr</code> are wrappers around the standard Unix file descriptors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stdout" class="anchored"><a href="#val-stdout" class="anchor"></a><code><span><span class="keyword">val</span> stdout : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-stderr" class="anchored"><a href="#val-stderr" class="anchor"></a><code><span><span class="keyword">val</span> stderr : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-with_file_descr" class="anchored"><a href="#val-with_file_descr" class="anchor"></a><code><span><span class="keyword">val</span> with_file_descr : 
  <span>?nonblocking:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>[ <span>`Ok of <span class="type-var">'a</span></span> <span>| `Already_closed</span> <span><span>| `Error</span> of exn</span> ]</span></span></code></div><div class="spec-doc"><p><code>with_file_descr t f</code> runs <code>f</code> on the file descriptor underlying <code>t</code>, if <code>is_open t</code>, and returns <code>`Ok</code> or <code>`Error</code> according to <code>f</code>. If <code>is_closed t</code>, then it does not call <code>f</code> and returns <code>`Already_closed</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_file_descr_exn" class="anchored"><a href="#val-with_file_descr_exn" class="anchor"></a><code><span><span class="keyword">val</span> with_file_descr_exn : 
  <span>?nonblocking:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_file_descr_exn</code> is like <code>with_file_descr</code> except that it raises rather than return <code>`Already_closed</code> or <code>`Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_file_descr_deferred" class="anchored"><a href="#val-with_file_descr_deferred" class="anchor"></a><code><span><span class="keyword">val</span> with_file_descr_deferred : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`Ok of <span class="type-var">'a</span></span> <span>| `Already_closed</span> <span><span>| `Error</span> of exn</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>with_file_descr_deferred t f</code> runs <code>f</code> on the file descriptor underlying <code>t</code>, if <code>is_open t</code>, and returns <code>`Ok</code> or <code>`Error</code> according to <code>f</code>. If <code>is_closed t</code>, then it does not call <code>f</code> and returns <code>`Already_closed</code>. It ensures that the file descriptor underlying <code>t</code> is not closed until the result of <code>f</code> becomes determined (or <code>f</code> raises).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_file_descr_deferred_exn" class="anchored"><a href="#val-with_file_descr_deferred_exn" class="anchor"></a><code><span><span class="keyword">val</span> with_file_descr_deferred_exn : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>with_file_descr_deferred_exn</code> is like <code>with_file_descr_deferred</code>, except that it raises rather than return <code>`Already_closed</code> or <code>`Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interruptible_ready_to" class="anchored"><a href="#val-interruptible_ready_to" class="anchor"></a><code><span><span class="keyword">val</span> interruptible_ready_to : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Read <span>| `Write</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>interrupt:<span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Bad_fd <span>| `Closed</span> <span>| `Interrupted</span> <span>| `Ready</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>interruptible_ready_to t read_write ~interrupt</code> returns a deferred that will become determined when the file descriptor underlying <code>t</code> can be read from or written to without blocking, or when <code>interrupt</code> becomes determined.</p><p>It's an error to make multiple concurrent calls to <code>*ready_to</code> functions on the same file descriptor.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ready_to" class="anchored"><a href="#val-ready_to" class="anchor"></a><code><span><span class="keyword">val</span> ready_to : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Read <span>| `Write</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Bad_fd <span>| `Closed</span> <span>| `Ready</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>ready_to t read_write</code> is like <code>interruptible_ready_to</code>, but without the possibility of interruption.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interruptible_every_ready_to" class="anchored"><a href="#val-interruptible_every_ready_to" class="anchor"></a><code><span><span class="keyword">val</span> interruptible_every_ready_to : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Read <span>| `Write</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>interrupt:<span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Bad_fd <span>| `Closed</span> <span>| `Unsupported</span> <span>| `Interrupted</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>interruptible_every_ready_to t read_write ~interrupt f a</code> checks every Async cycle whether the file descriptor underlying <code>t</code> can be read from or written to without blocking, and if so, enqueues a job to run <code>f a</code>. <code>interruptible_every_ready_to</code> is level triggered -- it will enqueue a job every cycle if I/O is available, even if the prior job hasn't run yet, or the job ran but did not consume the available data. <code>interruptible_every_ready_to</code> returns a deferred that will become determined when <code>interrupt</code> becomes determined or the file descriptor is closed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-every_ready_to" class="anchored"><a href="#val-every_ready_to" class="anchor"></a><code><span><span class="keyword">val</span> every_ready_to : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Read <span>| `Write</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Bad_fd <span>| `Closed</span> <span>| `Unsupported</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>every_ready_to t read_write f x</code> is like <code>interruptible_every_ready_to</code>, but without the possibility of interruption.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-syscall" class="anchored"><a href="#val-syscall" class="anchor"></a><code><span><span class="keyword">val</span> syscall : 
  <span>?nonblocking:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>[ `Already_closed <span><span>| `Ok</span> of <span class="type-var">'a</span></span> <span><span>| `Error</span> of exn</span> ]</span></span></code></div><div class="spec-doc"><p><code>syscall t f</code> runs <code>Async_unix.syscall</code> with <code>f</code> on the file descriptor underlying <code>t</code>, if <code>is_open t</code>, and returns <code>`Ok</code> or <code>`Error</code> according to <code>f</code>. If <code>is_closed t</code>, it does not call <code>f</code> and returns <code>`Already_closed</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-syscall_exn" class="anchored"><a href="#val-syscall_exn" class="anchor"></a><code><span><span class="keyword">val</span> syscall_exn : 
  <span>?nonblocking:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>syscall_exn t f</code> is like <code>syscall</code>, except it raises rather than return <code>`Already_closed</code> or <code>`Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-syscall_result_exn" class="anchored"><a href="#val-syscall_result_exn" class="anchor"></a><code><span><span class="keyword">val</span> syscall_result_exn : 
  <span>?nonblocking:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../../../core_unix/Core_unix/Syscall_result/index.html#type-t">Core_unix.Syscall_result.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../core_unix/Core_unix/Syscall_result/index.html#type-t">Core_unix.Syscall_result.t</a></span></span></code></div><div class="spec-doc"><p><code>syscall_result_exn t f a</code> is like <code>syscall_exn</code>, except it does not allocate except in exceptional cases. <code>a</code> is passed unchanged to <code>f</code>, and should be used to eliminate allocations due to closure capture.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-syscall_in_thread" class="anchored"><a href="#val-syscall_in_thread" class="anchor"></a><code><span><span class="keyword">val</span> syscall_in_thread : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>name:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Already_closed <span><span>| `Ok</span> of <span class="type-var">'a</span></span> <span><span>| `Error</span> of exn</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>syscall_in_thread t f</code> runs <code>In_thread.syscall</code> with <code>f</code> on the file descriptor underlying <code>t</code>, if <code>is_open t</code>, and returns a deferred that becomes determined with <code>`Ok</code> or <code>`Error</code> when the system call completes. If <code>is_closed t</code>, it does not call <code>f</code> and returns <code>`Already_closed</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-syscall_in_thread_exn" class="anchored"><a href="#val-syscall_in_thread_exn" class="anchor"></a><code><span><span class="keyword">val</span> syscall_in_thread_exn : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>name:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>syscall_in_thread_exn</code> is like <code>syscall_in_thread</code>, except it raises rather than return <code>`Already_closed</code> or <code>`Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_in_channel" class="anchored"><a href="#val-of_in_channel" class="anchor"></a><code><span><span class="keyword">val</span> of_in_channel : <span><a href="../../../stdio/Stdio/In_channel/index.html#type-t">Core.In_channel.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Kind/index.html#type-t">Kind.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_in_channel</code> and <code>of_out_channel</code> create an fd from their underlying file descriptor.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_out_channel" class="anchored"><a href="#val-of_out_channel" class="anchor"></a><code><span><span class="keyword">val</span> of_out_channel : <span><a href="../../../stdio/Stdio/Out_channel/index.html#type-t">Core.Out_channel.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Kind/index.html#type-t">Kind.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_in_channel_auto" class="anchored"><a href="#val-of_in_channel_auto" class="anchor"></a><code><span><span class="keyword">val</span> of_in_channel_auto : <span><a href="../../../stdio/Stdio/In_channel/index.html#type-t">Core.In_channel.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>of_in_channel_auto ic</code> is just like <code>of_in_channel</code>, but uses <code>fstat</code> to determine the kind. It makes some assumptions about sockets, specifically it assumes that a socket is either listening or connected to something (and it uses <code>getsockopt</code> to find out which). Don't pass an <code>in_channel</code> containing an unconnected non-listening socket.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_out_channel_auto" class="anchored"><a href="#val-of_out_channel_auto" class="anchor"></a><code><span><span class="keyword">val</span> of_out_channel_auto : <span><a href="../../../stdio/Stdio/Out_channel/index.html#type-t">Core.Out_channel.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>of_out_channel_auto ic</code> is just like <code>of_out_channel</code>, but uses <code>fstat</code> to determine the kind. It makes some assumptions about sockets, specifically it assumes that a socket is either listening or connected to something (and it uses <code>getsockopt</code> to find out which). Don't pass an <code>in_channel</code> containing an unconnected non listening socket.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-file_descr_exn" class="anchored"><a href="#val-file_descr_exn" class="anchor"></a><code><span><span class="keyword">val</span> file_descr_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../core_unix/Core_unix/File_descr/index.html#type-t">Core_unix.File_descr.t</a></span></code></div><div class="spec-doc"><p><code>file_descr_exn t</code> returns the file descriptor underlying <code>t</code>, unless <code>is_closed t</code>, in which case it raises. One must be very careful when using this function, and should try not to, since any uses of the resulting file descriptor are unknown to the <code>Fd</code> module, and hence can violate the guarantee it is trying to enforce.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int_exn" class="anchored"><a href="#val-to_int_exn" class="anchor"></a><code><span><span class="keyword">val</span> to_int_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>to_int_exn t</code> returns the the underlying file descriptor as an int. It has the same caveats as <code>file_descr_exn</code>.</p></div></div></div></body></html>