<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Thread_safe (async_unix.Async_unix.Thread_safe)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Thread_safe</nav><header class="odoc-preamble"><h1>Module <code><span>Async_unix.Thread_safe</span></code></h1><p>The <code>Thread_safe</code> module has functions that are safe to call from threads outside Async, such as the ones spawned by <code>In_thread.run</code>.</p><p>This is in contrast with the rest of <code>Async</code> library which is generally not thread-safe.</p><p>All the <code>Thread_safe.block*</code> and <code>Thread_safe.run*</code> functions wake up the Async scheduler to ensure that it continues in a timely manner with whatever jobs got started. Some functions take an optional <code>?wakeup_scheduler:bool</code> argument, which defaults to <code>true</code>. One can cause the scheduler to not be woken up by supplying <code>~wakeup_scheduler:false</code>, which can reduce CPU use, but increase latency, because the scheduler may not wake up for a while to process jobs.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-am_holding_async_lock" class="anchored"><a href="#val-am_holding_async_lock" class="anchor"></a><code><span><span class="keyword">val</span> am_holding_async_lock : <span>unit <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>am_holding_async_lock ()</code> returns true if the currently running thread is holding the Async lock.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-deferred" class="anchored"><a href="#val-deferred" class="anchor"></a><code><span><span class="keyword">val</span> deferred : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> * <span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span></span></code></div><div class="spec-doc"><p><code>deferred ()</code> returns <code>(d, fill)</code> where <code>d</code> is a deferred that will become determined with value <code>v</code> once <code>fill v</code> is called.</p><p>It is ok to call <code>deferred</code> from inside or outside Async. <code>fill</code> must be called from outside Async.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_in_async_with_optional_cycle" class="anchored"><a href="#val-run_in_async_with_optional_cycle" class="anchor"></a><code><span><span class="keyword">val</span> run_in_async_with_optional_cycle : 
  <span>?wakeup_scheduler:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span>[ `Run_a_cycle <span>| `Do_not_run_a_cycle</span> ]</span> * <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, exn )</span> <a href="../../../core/Core/Result/index.html#type-t">Core.Result.t</a></span></span></code></div><div class="spec-doc"><p><code>run_in_async_with_optional_cycle f</code> acquires the Async lock and runs <code>f ()</code> while holding the lock. Depending on the result of <code>f</code>, it may also run a cycle.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_in_async" class="anchored"><a href="#val-run_in_async" class="anchor"></a><code><span><span class="keyword">val</span> run_in_async : 
  <span>?wakeup_scheduler:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, exn )</span> <a href="../../../core/Core/Result/index.html#type-t">Core.Result.t</a></span></span></code></div><div class="spec-doc"><p><code>run_in_async f</code> acquires the Async lock and runs <code>f ()</code> while holding the lock. It returns the result of <code>f ()</code> to the outside world. The scheduler is woken up to ensure the code that depends on <code>f ()</code> is run soon enough.</p><p><code>run_in_async</code> doesn't run a cycle.</p><p><code>run_in_async</code> does not automatically start the Async scheduler. You still need to call <code>Scheduler.go</code> elsewhere in your program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_in_async_exn" class="anchored"><a href="#val-run_in_async_exn" class="anchor"></a><code><span><span class="keyword">val</span> run_in_async_exn : <span>?wakeup_scheduler:bool <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-block_on_async" class="anchored"><a href="#val-block_on_async" class="anchor"></a><code><span><span class="keyword">val</span> block_on_async : 
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, exn )</span> <a href="../../../core/Core/Result/index.html#type-t">Core.Result.t</a></span></span></code></div><div class="spec-doc"><p><code>block_on_async f</code> runs <code>f ()</code> in the Async world and blocks until the result becomes determined. This function can be called from the main thread (before Async is started) or from a thread outside Async.</p><p><code>block_on_async</code> will run a cycle if the deferred isn't determined, in the hope that running the cycle will cause the deferred to become determined.</p><p><code>block_on_async</code> will automatically start the scheduler if it isn't already running.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_on_async_exn" class="anchored"><a href="#val-block_on_async_exn" class="anchor"></a><code><span><span class="keyword">val</span> block_on_async_exn : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-run_in_async_wait" class="anchored"><a href="#val-run_in_async_wait" class="anchor"></a><code><span><span class="keyword">val</span> run_in_async_wait : 
  <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, exn )</span> <a href="../../../core/Core/Result/index.html#type-t">Core.Result.t</a></span></span></code></div><div class="spec-doc"><p><code>run_in_async_wait f</code> is like <code>block_on_async f</code>, except that it must be called from a thread outside Async. Upon returning from <code>run_in_async_wait</code>, it is guaranteed that the caller does not have the Async lock.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_in_async_wait_exn" class="anchored"><a href="#val-run_in_async_wait_exn" class="anchor"></a><code><span><span class="keyword">val</span> run_in_async_wait_exn : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-reset_scheduler" class="anchored"><a href="#val-reset_scheduler" class="anchor"></a><code><span><span class="keyword">val</span> reset_scheduler : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>reset_scheduler</code> stops the scheduler thread and any associated threads, and resets Async's global state to its initial state. This is useful if you need to first use Async to compute a value and then to daemonize (in which case you should <code>daemonize</code> with <code>~allow_threads_to_have_been_created:true</code>).</p><p><code>reset_scheduler</code> can be called from the main thread (before Async is started) or from a thread outside Async. <code>reset_scheduler</code> is known to be imperfect, and to have races in which there are still threads running after it returns.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-without_async_lock" class="anchored"><a href="#val-without_async_lock" class="anchor"></a><code><span><span class="keyword">val</span> without_async_lock : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>without_async_lock f</code> can not be called from async, usually because <code>f</code> is expected to block. It's safe to call it in these two circumstances:</p><ul><li>from a separate thread that's not holding the async lock</li><li>from the main thread, even if it is holding the async lock, as long as it's not running async jobs. In the latter case the async lock is dropped for the duration of <code>f</code>.</li></ul></div></div></div></body></html>