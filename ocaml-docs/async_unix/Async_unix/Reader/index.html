<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Reader (async_unix.Async_unix.Reader)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Reader</nav><header class="odoc-preamble"><h1>Module <code><span>Async_unix.Reader</span></code></h1><p><code>Reader</code> is Async's main API for buffered input from a file descriptor. It is the analog of <a href="../../../stdio/Stdio/In_channel/index.html"><code>Stdio.In_channel</code></a>.</p><p>Each reader has an internal buffer, which is filled via <code>read()</code> system calls when data is needed to satisfy a <code>Reader.read*</code> call.</p><p>Each of the read functions returns a deferred that will become determined when the read completes. It is an error to have two simultaneous reads. That is, if you call a read function, you should not call another read function until the first one completes.</p><p>If the file descriptor underlying a reader is closed, the reader will return EOF (after all the buffered bytes have been read).</p><p>Any <code>Reader.read*</code> call could, rather than determine its result, send an exception to the monitor in effect when <code>read</code> was called. Such exceptions can be handled in the usual way by using <code>try_with</code>, e.g.:</p><pre><code>try_with (fun () -&gt; Reader.read reader ...) </code></pre></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Read_result" class="anchored"><a href="#module-Read_result" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Read_result/index.html">Read_result</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Id" class="anchored"><a href="#module-Id" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Id/index.html">Id</a></span><span> : <a href="../../../core/Core/Unique_id/module-type-Id/index.html">Core.Unique_id</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../async_kernel/Async_kernel/Invariant/module-type-S/index.html">Async_kernel.Invariant.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../async_kernel/Async_kernel/Invariant/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-invariant" class="anchored"><a href="#val-invariant" class="anchor"></a><code><span><span class="keyword">val</span> invariant : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-io_stats" class="anchored"><a href="#val-io_stats" class="anchor"></a><code><span><span class="keyword">val</span> io_stats : <a href="../Io_stats/index.html#type-t">Io_stats.t</a></span></code></div><div class="spec-doc"><p>Overall IO statistics for all readers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-last_read_time" class="anchored"><a href="#val-last_read_time" class="anchor"></a><code><span><span class="keyword">val</span> last_read_time : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../core_unix/Time_unix/index.html#type-t">Time_unix.t</a></span></code></div><div class="spec-doc"><p>Returns time of the most recent <code>read</code> system call that returned data.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stdin" class="anchored"><a href="#val-stdin" class="anchor"></a><code><span><span class="keyword">val</span> stdin : <span><a href="#type-t">t</a> <a href="../../../core/Core/Lazy/index.html#type-t">Core.Lazy.t</a></span></span></code></div><div class="spec-doc"><p><code>stdin</code> is a reader for file descriptor 0. It is lazy because we don't want to create it in all programs that happen to link with Async.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-open_file" class="anchored"><a href="#val-open_file" class="anchor"></a><code><span><span class="keyword">val</span> open_file : <span>?buf_len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>open_file file</code> opens <code>file</code> for reading and returns a reader reading from it.</p><p>This may raise an exception for the typical reasons that an <code>open(2)</code> system call may fail. If it does raise, it's guaranteed to be a <code>Unix_error</code> variant.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-transfer" class="anchored"><a href="#val-transfer" class="anchor"></a><code><span><span class="keyword">val</span> transfer : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <a href="../../../async_kernel/Async_kernel/Pipe/Writer/index.html#type-t">Async_kernel.Pipe.Writer.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>transfer t pipe_w</code> transfers data from <code>t</code> into <code>pipe_w</code> one chunk at a time (whatever is read from the underlying file descriptor without post-processing). The result becomes determined after reaching EOF on <code>t</code> and the final bytes have been transferred, or if <code>pipe_w</code> is closed.</p><p>This function will normally not be needed (see <code>pipe</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pipe" class="anchored"><a href="#val-pipe" class="anchor"></a><code><span><span class="keyword">val</span> pipe : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../../../async_kernel/Async_kernel/Pipe/Reader/index.html#type-t">Async_kernel.Pipe.Reader.t</a></span></span></code></div><div class="spec-doc"><p><code>pipe t</code> returns the reader end of a pipe that will continually be filled with chunks of data from the underlying <code>Reader.t</code>. When the reader reaches EOF or the pipe is closed, <code>pipe</code> closes the reader, and then after the reader close is finished, closes the pipe.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_pipe" class="anchored"><a href="#val-of_pipe" class="anchor"></a><code><span><span class="keyword">val</span> of_pipe : 
  <span><a href="../../../core/Core/Info/index.html#type-t">Core.Info.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <a href="../../../async_kernel/Async_kernel/Pipe/Reader/index.html#type-t">Async_kernel.Pipe.Reader.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>of_pipe info pipe_r</code> returns a reader <code>t</code> that receives all the data from <code>pipe_r</code>. If <code>pipe_r</code> is closed, <code>t</code> will see an EOF (but will not be automatically closed). If <code>t</code> is closed, then <code>pipe_r</code> will stop being drained.</p><p><code>of_pipe</code> is implemented by shuttling bytes from <code>pipe_r</code> to the write-end of a Unix pipe, with <code>t</code> being attached to the read end of the Unix pipe.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>?buf_len:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Fd/index.html#type-t">Fd.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create ~buf_len fd</code> creates a new reader that is reading from <code>fd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_in_channel" class="anchored"><a href="#val-of_in_channel" class="anchor"></a><code><span><span class="keyword">val</span> of_in_channel : <span><a href="../../../stdio/Stdio/In_channel/index.html#type-t">Core.In_channel.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Fd/Kind/index.html#type-t">Fd.Kind.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-with_file" class="anchored"><a href="#val-with_file" class="anchor"></a><code><span><span class="keyword">val</span> with_file : 
  <span>?buf_len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?exclusive:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>with_file file f</code> opens <code>file</code>, creates a reader with it, and passes the reader to <code>f</code>. It closes the reader when the result of <code>f</code> becomes determined, and returns <code>f</code>'s result.</p><p>This may raise an exception for the typical reasons that an <code>open(2)</code> system call may fail. If it does raise before <code>f</code> is called, it's guaranteed to be a <code>Unix_error</code> variant.</p><p><b>Note:</b> You need to be careful that all your IO is done when the deferred you return becomes determined. If for example you use <code>with_file</code> and call <code>lines</code>, make sure you return a deferred that becomes determined when the EOF is reached on the pipe, not when you get the pipe (because you get it straight away).</p><p><code>exclusive = true</code> uses a filesystem lock to try and make sure that the file is not read while it's being modified. This is an advisory lock, which means that the writer must be cooperating by taking a relevant lock when writing (see <code>Writer.with_file</code>). This is unrelated and should not be confused with the <code>O_EXCL</code> flag in <code>open</code> systemcall. Note that the implementation uses <code>Unix.lockf</code>, which has known pitfalls. It's recommended that you avoid the <code>exclusive</code> flag in favor of using a library dedicated to dealing with file locks where the pitfalls can be documented in detail.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>close t</code> prevents further use of <code>t</code> and closes <code>t</code>'s underlying file descriptor. The result of <code>close</code> becomes determined once the underlying file descriptor has been closed. It is an error to call other operations on <code>t</code> after <code>close t</code> has been called, except that calls of <code>close</code> subsequent to the original call to <code>close</code> will return the same deferred as the original call.</p><p><code>close_finished t</code> becomes determined after <code>t</code>'s underlying file descriptor has been closed, i.e., it is the same as the result of <code>close</code>. <code>close_finished</code> differs from <code>close</code> in that it does not have the side effect of initiating a close.</p><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> has been called.</p><p><code>with_close t ~f</code> runs <code>f ()</code>, and closes <code>t</code> after <code>f</code> finishes or raises.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close_finished" class="anchored"><a href="#val-close_finished" class="anchor"></a><code><span><span class="keyword">val</span> close_finished : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_closed" class="anchored"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-with_close" class="anchored"><a href="#val-with_close" class="anchor"></a><code><span><span class="keyword">val</span> with_close : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-id" class="anchored"><a href="#val-id" class="anchor"></a><code><span><span class="keyword">val</span> id : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Id/index.html#type-t">Id.t</a></span></code></div><div class="spec-doc"><p><code>id</code> returns a name for this reader that is unique across all instances of the reader module.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fd" class="anchored"><a href="#val-fd" class="anchor"></a><code><span><span class="keyword">val</span> fd : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Fd/index.html#type-t">Fd.t</a></span></code></div><div class="spec-doc"><p><code>fd</code> returns the <code>Fd.t</code> used to create this reader.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read" class="anchored"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?pos:int <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core/Core/Bytes/index.html#type-t">Core.Bytes.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>int <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read t ?pos ?len buf</code> reads up to <code>len</code> bytes into <code>buf</code>, blocking until some data is available or EOF is reached. The resulting <code>i</code> satisfies <code>0 &lt; i &lt;= len</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>peek t ~len</code> peeks exactly <code>len</code> bytes from <code>t</code>'s buffer. It blocks until <code>len</code> bytes are available or EOF is reached.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes_available" class="anchored"><a href="#val-bytes_available" class="anchor"></a><code><span><span class="keyword">val</span> bytes_available : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Reports how many bytes of data are currently in the reader's buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_available" class="anchored"><a href="#val-read_available" class="anchor"></a><code><span><span class="keyword">val</span> read_available : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?pos:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../core/Core/Bytes/index.html#type-t">Core.Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Consumes data from the reader's buffer without performing any additional I/O.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek_available" class="anchored"><a href="#val-peek_available" class="anchor"></a><code><span><span class="keyword">val</span> peek_available : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Reads up to <code>len</code> bytes from the reader's buffer without consuming it and without performing any additional I/O.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drain" class="anchored"><a href="#val-drain" class="anchor"></a><code><span><span class="keyword">val</span> drain : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>drain t</code> reads and ignores all data from <code>t</code> until it hits EOF, and then closes <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-read_one_chunk_at_a_time_result" class="anchored"><a href="#type-read_one_chunk_at_a_time_result" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a read_one_chunk_at_a_time_result</span></span><span> = </span><span>[ </span></code><table><tr id="type-read_one_chunk_at_a_time_result.Eof" class="anchored"><td class="def constructor"><a href="#type-read_one_chunk_at_a_time_result.Eof" class="anchor"></a><code><span>| </span></code><code><span>`Eof</span></code></td></tr><tr id="type-read_one_chunk_at_a_time_result.Stopped" class="anchored"><td class="def constructor"><a href="#type-read_one_chunk_at_a_time_result.Stopped" class="anchor"></a><code><span>| </span></code><code><span>`Stopped <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>`Eof_with_unconsumed_data s</code> means that <code>handle_chunk</code> returned <code>`Consumed (c, _)</code> and left data in the reader's buffer (i.e., <code>c &lt; len</code>), and that the reader reached EOF without reading any more data into the buffer; hence the data in the buffer was never consumed (and never will be, since the reader is at EOF).</p><span class="comment-delim">*)</span></td></tr><tr id="type-read_one_chunk_at_a_time_result.Eof_with_unconsumed_data" class="anchored"><td class="def constructor"><a href="#type-read_one_chunk_at_a_time_result.Eof_with_unconsumed_data" class="anchor"></a><code><span>| </span></code><code><span>`Eof_with_unconsumed_data <span class="keyword">of</span> string</span></code></td></tr></table><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_read_one_chunk_at_a_time_result" class="anchored"><a href="#val-sexp_of_read_one_chunk_at_a_time_result" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_read_one_chunk_at_a_time_result : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-read_one_chunk_at_a_time_result">read_one_chunk_at_a_time_result</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-handle_chunk_result" class="anchored"><a href="#type-handle_chunk_result" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a handle_chunk_result</span></span><span> = </span><span>[ </span></code><table><tr id="type-handle_chunk_result.Stop" class="anchored"><td class="def constructor"><a href="#type-handle_chunk_result.Stop" class="anchor"></a><code><span>| </span></code><code><span>`Stop <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>`Stop a</code> means that <code>handle_chunk</code> consumed all <code>len</code> bytes, and that <code>read_one_chunk_at_a_time</code> should stop reading and return <code>`Stopped a</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-handle_chunk_result.Stop_consumed" class="anchored"><td class="def constructor"><a href="#type-handle_chunk_result.Stop_consumed" class="anchor"></a><code><span>| </span></code><code><span>`Stop_consumed <span class="keyword">of</span> <span class="type-var">'a</span> * int</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>`Stop_consumed (a, n)</code> means that <code>handle_chunk</code> consumed <code>n</code> bytes, and that <code>read_one_chunk_at_a_time</code> should stop reading and return <code>`Stopped a</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-handle_chunk_result.Continue" class="anchored"><td class="def constructor"><a href="#type-handle_chunk_result.Continue" class="anchor"></a><code><span>| </span></code><code><span>`Continue</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>`Continue</code> means that <code>handle_chunk</code> has consumed all <code>len</code> bytes.</p><span class="comment-delim">*)</span></td></tr><tr id="type-handle_chunk_result.Consumed" class="anchored"><td class="def constructor"><a href="#type-handle_chunk_result.Consumed" class="anchor"></a><code><span>| </span></code><code><span>`Consumed <span class="keyword">of</span> int * <span>[ <span>`Need of int</span> <span>| `Need_unknown</span> ]</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>`Consumed (c, need)</code> means that <code>c</code> bytes were consumed and <code>need</code> says how many bytes are needed (including the data remaining in the buffer after the <code>c</code> were already consumed). It is an error if <code>c &lt; 0 || c &gt; len</code>. For <code>`Need n</code>, it is an error if <code>n &lt; 0 || c + n &lt;= len</code>.</p><span class="comment-delim">*)</span></td></tr></table><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_handle_chunk_result" class="anchored"><a href="#val-sexp_of_handle_chunk_result" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_handle_chunk_result : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-handle_chunk_result">handle_chunk_result</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_one_chunk_at_a_time" class="anchored"><a href="#val-read_one_chunk_at_a_time" class="anchor"></a><code><span><span class="keyword">val</span> read_one_chunk_at_a_time : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>handle_chunk:
    <span>( <span><a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <span class="arrow">&#45;&gt;</span></span>
      <span>pos:int <span class="arrow">&#45;&gt;</span></span>
      <span>len:int <span class="arrow">&#45;&gt;</span></span>
      <span><span><span class="type-var">'a</span> <a href="#type-handle_chunk_result">handle_chunk_result</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-read_one_chunk_at_a_time_result">read_one_chunk_at_a_time_result</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_one_chunk_at_a_time t ~handle_chunk</code> reads into <code>t</code>'s internal buffer, and whenever bytes are available, applies <code>handle_chunk</code> to them. It waits to read again until the deferred returned by <code>handle_chunk</code> becomes determined. If <code>handle_chunk</code> returns <code>`Consumed</code>, then <code>read_one_chunk_at_a_time</code> will wait for additional data to arrive before calling <code>handle_chunk</code> again. Thus, <code>handle_chunk</code> should consume as much as possible.</p><p><code>read_one_chunk_at_a_time</code> continues reading until it reaches <code>`Eof</code> or <code>handle_chunk</code> returns <code>`Stop</code> or <code>`Stop_consumed</code>. In the case of <code>`Stop</code> and <code>`Stop_consumed</code>, one may read from <code>t</code> after <code>read_one_chunk_at_a_time</code> returns.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-handle_iobuf_result" class="anchored"><a href="#type-handle_iobuf_result" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a handle_iobuf_result</span></span><span> = </span><span>[ </span></code><table><tr id="type-handle_iobuf_result.Stop" class="anchored"><td class="def constructor"><a href="#type-handle_iobuf_result.Stop" class="anchor"></a><code><span>| </span></code><code><span>`Stop <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td></tr><tr id="type-handle_iobuf_result.Continue" class="anchored"><td class="def constructor"><a href="#type-handle_iobuf_result.Continue" class="anchor"></a><code><span>| </span></code><code><span>`Continue</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p><code>`Stop a</code> or <code>`Continue</code> respects the usual <code>Iobuf</code> semantics where data up to the <code>Iobuf.Lo_bound</code> is considered consumed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_handle_iobuf_result" class="anchored"><a href="#val-sexp_of_handle_iobuf_result" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_handle_iobuf_result : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-handle_iobuf_result">handle_iobuf_result</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_one_iobuf_at_a_time" class="anchored"><a href="#val-read_one_iobuf_at_a_time" class="anchor"></a><code><span><span class="keyword">val</span> read_one_iobuf_at_a_time : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>handle_chunk:
    <span>( <span><span><span>( <a href="../../../core/Core/index.html#type-read_write">Core.read_write</a>, <a href="../../../core_kernel/Iobuf/index.html#type-seek">Iobuf.seek</a> )</span> <a href="../../../core_kernel/Iobuf/index.html#type-t">Iobuf.t</a></span> <span class="arrow">&#45;&gt;</span></span>
      <span><span><span class="type-var">'a</span> <a href="#type-handle_iobuf_result">handle_iobuf_result</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-read_one_chunk_at_a_time_result">read_one_chunk_at_a_time_result</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_one_iobuf_at_a_time</code> is like <code>read_one_chunk_at_a_time</code>, except that the user-supplied <code>handle_chunk</code> function receives its data in an <code>Iobuf.t</code>, and uses the <code>Iobuf</code> position to communicate how much data was consumed. <code>read_one_iobuf_at_a_time</code> is implemented as a wrapper around <code>read_one_chunk_at_a_time</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_substring" class="anchored"><a href="#val-read_substring" class="anchor"></a><code><span><span class="keyword">val</span> read_substring : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core/Core/Substring/index.html#type-t">Core.Substring.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>int <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_substring t ss</code> reads up to <code>Substring.length ss</code> bytes into <code>ss</code>, blocking until some data is available or EOF is reached. The resulting <code>i</code> satisfies <code>0 &lt; i &lt;=
    Substring.length ss</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_bigsubstring" class="anchored"><a href="#val-read_bigsubstring" class="anchor"></a><code><span><span class="keyword">val</span> read_bigsubstring : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core/Core/Bigsubstring/index.html#type-t">Core.Bigsubstring.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>int <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_char" class="anchored"><a href="#val-read_char" class="anchor"></a><code><span><span class="keyword">val</span> read_char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-really_read" class="anchored"><a href="#val-really_read" class="anchor"></a><code><span><span class="keyword">val</span> really_read : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?pos:int <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core/Core/Bytes/index.html#type-t">Core.Bytes.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Ok <span><span>| `Eof</span> of int</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>really_read t buf ?pos ?len</code> reads until it fills <code>len</code> bytes of <code>buf</code> starting at <code>pos</code>, or runs out of input. In the former case it returns <code>`Ok</code>. In the latter, it returns <code>`Eof n</code> where <code>n</code> is the number of bytes that were read before end of input, and <code>0 &lt;= n &lt; String.length ss</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-really_read_substring" class="anchored"><a href="#val-really_read_substring" class="anchor"></a><code><span><span class="keyword">val</span> really_read_substring : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core/Core/Substring/index.html#type-t">Core.Substring.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Ok <span><span>| `Eof</span> of int</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-really_read_bigsubstring" class="anchored"><a href="#val-really_read_bigsubstring" class="anchor"></a><code><span><span class="keyword">val</span> really_read_bigsubstring : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../core/Core/Bigsubstring/index.html#type-t">Core.Bigsubstring.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Ok <span><span>| `Eof</span> of int</span> ]</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_until" class="anchored"><a href="#val-read_until" class="anchor"></a><code><span><span class="keyword">val</span> read_until : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`Pred of <span>char <span class="arrow">&#45;&gt;</span></span> bool</span> <span><span>| `Char</span> of char</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>keep_delim:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`Ok of string</span> <span><span>| `Eof_without_delim</span> of string</span> <span>| `Eof</span> ]</span>
    <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_until t pred ~keep_delim</code> reads until it hits a delimiter <code>c</code> such that:</p><ul><li>if <code>pred = `Char c'</code> then <code>c = c'</code></li><li>if <code>pred = `Pred p</code> then <code>p c</code></li></ul><p><code>`Char c'</code> is equivalent to <code>`Pred (fun c -&gt; c = c')</code> but the underlying implementation is more efficient, in particular it will not call a function on every input character.</p><p><code>read_until</code> returns a freshly-allocated string consisting of all the characters read and optionally including the delimiter as per <code>keep_delim</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_until_bounded" class="anchored"><a href="#val-read_until_bounded" class="anchor"></a><code><span><span class="keyword">val</span> read_until_bounded : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`Pred of <span>char <span class="arrow">&#45;&gt;</span></span> bool</span> <span><span>| `Char</span> of char</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>keep_delim:bool <span class="arrow">&#45;&gt;</span></span>
  <span>max:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`Ok of string</span>
  <span><span>| `Eof_without_delim</span> of string</span>
  <span>| `Eof</span>
  <span><span>| `Max_exceeded</span> of string</span> ]</span>
    <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_until_bounded</code> is just like <code>read_until</code>, except you have the option of specifying a maximum number of chars to read (not including the separator).</p><p>When <code>`Max_exceeded str</code> is returned, the length of <code>str</code> will be equal to <code>max + 1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_line" class="anchored"><a href="#val-read_line" class="anchor"></a><code><span><span class="keyword">val</span> read_line : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_line t</code> reads up to and including the next newline (<code>\n</code>) character (or <code>\r\n</code>) and returns a freshly-allocated string containing everything up to but not including the newline character. If <code>read_line</code> encounters EOF before the newline char then everything read up to but not including EOF will be returned as a line.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-really_read_line" class="anchored"><a href="#val-really_read_line" class="anchor"></a><code><span><span class="keyword">val</span> really_read_line : 
  <span>wait_time:<a href="../../../core_unix/Time_unix/Span/index.html#type-t">Time_unix.Span.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string option</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>really_read_line ~wait_time t</code> reads up to and including the next newline (<code>\n</code>) character and returns an optional, freshly-allocated string containing everything up to but not including the newline character. If <code>really_read_line</code> encounters EOF before the newline char, then a time span of <code>wait_time</code> will be used before the input operation is retried. If the descriptor is closed, <code>None</code> will be returned.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-read" class="anchored"><a href="#type-read" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a read</span></span><span> = <span>?parse_pos:<a href="../../../core/Core/Sexp/Parse_pos/index.html#type-t">Core.Sexp.Parse_pos.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_sexp" class="anchored"><a href="#val-read_sexp" class="anchor"></a><code><span><span class="keyword">val</span> read_sexp : <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../../core/Core/Sexp/index.html#type-t">Core.Sexp.t</a> <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <a href="#type-read">read</a></span></span></code></div><div class="spec-doc"><p><code>read_sexp t</code> reads the next sexp.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_sexps" class="anchored"><a href="#val-read_sexps" class="anchor"></a><code><span><span class="keyword">val</span> read_sexps : <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../core/Core/Sexp/index.html#type-t">Core.Sexp.t</a> <a href="../../../async_kernel/Async_kernel/Pipe/Reader/index.html#type-t">Async_kernel.Pipe.Reader.t</a></span> )</span> <a href="#type-read">read</a></span></span></code></div><div class="spec-doc"><p><code>read_sexps t</code> reads all the sexps and returns them as a pipe. When the reader reaches EOF or the pipe is closed, <code>read_sexps</code> closes the reader, and then after the reader close is finished, closes the pipe.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_annotated_sexps" class="anchored"><a href="#val-read_annotated_sexps" class="anchor"></a><code><span><span class="keyword">val</span> read_annotated_sexps : 
  <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../core/Core/Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a> <a href="../../../async_kernel/Async_kernel/Pipe/Reader/index.html#type-t">Async_kernel.Pipe.Reader.t</a></span> )</span> <a href="#type-read">read</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_bin_prot" class="anchored"><a href="#val-read_bin_prot" class="anchor"></a><code><span><span class="keyword">val</span> read_bin_prot : 
  <span>?max_len:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_bin_prot ?max_len t bp_reader</code> reads the next binary protocol message using binary protocol reader <code>bp_reader</code>. The format is the &quot;size-prefixed binary protocol&quot;, in which the length of the data is prefixed as a 64-bit integer to the data. This is the format that <code>Writer.write_bin_prot</code> writes.</p><p>For higher performance, consider <code>Unpack_sequence.unpack_bin_prot_from_reader</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek_bin_prot" class="anchored"><a href="#val-peek_bin_prot" class="anchor"></a><code><span><span class="keyword">val</span> peek_bin_prot : 
  <span>?max_len:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <code>read_bin_prot</code>, but doesn't consume any bytes from <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_marshal_raw" class="anchored"><a href="#val-read_marshal_raw" class="anchor"></a><code><span><span class="keyword">val</span> read_marshal_raw : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../../core/Core/Bytes/index.html#type-t">Core.Bytes.t</a> <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_marshal_raw</code> reads and returns a buffer containing one marshaled value, but doesn't unmarshal it. You can just call <code>Marshal.from_string</code> on the string, and cast it to the desired type (preferably the actual type). Similar to <code>Marshal.from_channel</code>, but suffers from the String-length limitation (16MB) on 32-bit platforms.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_marshal" class="anchored"><a href="#val-read_marshal" class="anchor"></a><code><span><span class="keyword">val</span> read_marshal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>read_marshal</code> is like <code>read_marshal_raw</code>, but unmarshals the value after reading it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-recv" class="anchored"><a href="#val-recv" class="anchor"></a><code><span><span class="keyword">val</span> recv : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../../core/Core/Bytes/index.html#type-t">Core.Bytes.t</a> <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>recv</code> returns a string that was written with <code>Writer.send</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_all" class="anchored"><a href="#val-read_all" class="anchor"></a><code><span><span class="keyword">val</span> read_all : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="Read_result/index.html#type-t">Read_result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Pipe/Reader/index.html#type-t">Async_kernel.Pipe.Reader.t</a></span></span></code></div><div class="spec-doc"><p><code>read_all t read_one</code> returns a pipe that receives all values read from <code>t</code> by repeatedly using <code>read_one t</code>. When the reader reaches EOF, it closes the reader, and then after the reader close is finished, closes the pipe.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lseek" class="anchored"><a href="#val-lseek" class="anchor"></a><code><span><span class="keyword">val</span> lseek : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int64 <span class="arrow">&#45;&gt;</span></span>
  <span>mode:<span>[&lt; `Set <span>| `End</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int64 <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>lseek t offset ~mode</code> clears <code>t</code>'s buffer and calls <code>Unix.lseek</code> on <code>t</code>'s file descriptor. The <code>`Cur</code> mode is not exposed because seeking relative to the current position of the file descriptor is not the same as seeking relative to the current position of the reader.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ltell" class="anchored"><a href="#val-ltell" class="anchor"></a><code><span><span class="keyword">val</span> ltell : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>ltell t</code> returns the file position of <code>t</code> from the perspective of a consumer of <code>t</code>. It uses <code>Unix.lseek</code> to find the file position of <code>t</code>'s underlying file descriptor, and then subtracts the number of bytes in <code>t</code>'s buffer that have been read from the OS but not from <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lines" class="anchored"><a href="#val-lines" class="anchor"></a><code><span><span class="keyword">val</span> lines : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../../../async_kernel/Async_kernel/Pipe/Reader/index.html#type-t">Async_kernel.Pipe.Reader.t</a></span></span></code></div><div class="spec-doc"><p><code>lines t</code> reads all the lines from <code>t</code> and puts them in the pipe, one line per pipe element. The lines do not contain the trailing newline. When the reader reaches EOF or the pipe is closed, <code>lines</code> closes the reader, and then after the reader close is finished, closes the pipe.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-contents" class="anchored"><a href="#val-contents" class="anchor"></a><code><span><span class="keyword">val</span> contents : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>contents t</code> returns the string corresponding to the full contents (up to EOF) of the reader. <code>contents</code> closes <code>t</code> before returning the string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-file_contents" class="anchored"><a href="#val-file_contents" class="anchor"></a><code><span><span class="keyword">val</span> file_contents : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>file_contents file</code> returns the string with the full contents of the file.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-file_lines" class="anchored"><a href="#val-file_lines" class="anchor"></a><code><span><span class="keyword">val</span> file_lines : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>file_lines file</code> returns a list of the lines in the file. The lines do not contain the trailing newline.</p></div></div><p><code>load_sexp file conv</code> loads a sexp from <code>file</code> and converts it to a value using <code>conv</code>. This function provides an accurate error location if <code>convert</code> raises <code>Of_sexp_error</code>.</p><p><code>load_sexps</code> is similar, but converts a sequence of sexps.</p><div class="odoc-spec"><div class="spec type" id="type-load" class="anchored"><a href="#type-load" class="anchor"></a><code><span><span class="keyword">type</span> <span>('sexp, 'a, 'b) load</span></span><span> =
  <span>?exclusive:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'sexp</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexp" class="anchored"><a href="#val-load_sexp" class="anchor"></a><code><span><span class="keyword">val</span> load_sexp : <span><span>( <a href="../../../core/Core/Sexp/index.html#type-t">Core.Sexp.t</a>, <span class="type-var">'a</span>, <span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> )</span> <a href="#type-load">load</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexp_exn" class="anchored"><a href="#val-load_sexp_exn" class="anchor"></a><code><span><span class="keyword">val</span> load_sexp_exn : <span><span>( <a href="../../../core/Core/Sexp/index.html#type-t">Core.Sexp.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span> )</span> <a href="#type-load">load</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexps" class="anchored"><a href="#val-load_sexps" class="anchor"></a><code><span><span class="keyword">val</span> load_sexps : <span><span>( <a href="../../../core/Core/Sexp/index.html#type-t">Core.Sexp.t</a>, <span class="type-var">'a</span>, <span><span><span class="type-var">'a</span> list</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> )</span> <a href="#type-load">load</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_sexps_exn" class="anchored"><a href="#val-load_sexps_exn" class="anchor"></a><code><span><span class="keyword">val</span> load_sexps_exn : <span><span>( <a href="../../../core/Core/Sexp/index.html#type-t">Core.Sexp.t</a>, <span class="type-var">'a</span>, <span><span class="type-var">'a</span> list</span> )</span> <a href="#type-load">load</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_annotated_sexp" class="anchored"><a href="#val-load_annotated_sexp" class="anchor"></a><code><span><span class="keyword">val</span> load_annotated_sexp : 
  <span><span>( <a href="../../../core/Core/Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a>, <span class="type-var">'a</span>, <span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> )</span> <a href="#type-load">load</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_annotated_sexp_exn" class="anchored"><a href="#val-load_annotated_sexp_exn" class="anchor"></a><code><span><span class="keyword">val</span> load_annotated_sexp_exn : <span><span>( <a href="../../../core/Core/Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span> )</span> <a href="#type-load">load</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_annotated_sexps" class="anchored"><a href="#val-load_annotated_sexps" class="anchor"></a><code><span><span class="keyword">val</span> load_annotated_sexps : 
  <span><span>( <a href="../../../core/Core/Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a>, <span class="type-var">'a</span>, <span><span><span class="type-var">'a</span> list</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> )</span> <a href="#type-load">load</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_annotated_sexps_exn" class="anchored"><a href="#val-load_annotated_sexps_exn" class="anchor"></a><code><span><span class="keyword">val</span> load_annotated_sexps_exn : <span><span>( <a href="../../../core/Core/Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a>, <span class="type-var">'a</span>, <span><span class="type-var">'a</span> list</span> )</span> <a href="#type-load">load</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-load_bin_prot" class="anchored"><a href="#type-load_bin_prot" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) load_bin_prot</span></span><span> =
  <span>?exclusive:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?max_len:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_bin_prot" class="anchored"><a href="#val-load_bin_prot" class="anchor"></a><code><span><span class="keyword">val</span> load_bin_prot : <span><span>( <span class="type-var">'a</span>, <span><span class="type-var">'a</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> )</span> <a href="#type-load_bin_prot">load_bin_prot</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-load_bin_prot_exn" class="anchored"><a href="#val-load_bin_prot_exn" class="anchor"></a><code><span><span class="keyword">val</span> load_bin_prot_exn : <span><span>( <span class="type-var">'a</span>, <span class="type-var">'a</span> )</span> <a href="#type-load_bin_prot">load_bin_prot</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-For_testing" class="anchored"><a href="#module-For_testing" class="anchor"></a><code><span><span class="keyword">module</span> <a href="For_testing/index.html">For_testing</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>