<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Process (async_unix.Async_unix.Process)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Process</nav><header class="odoc-preamble"><h1>Module <code><span>Async_unix.Process</span></code></h1><p><code>Async.Process</code> is for creating child processes of the current process, and communicating with children via their stdin, stdout, and stderr. <code>Async.Process</code> is the Async analog of <code>Core_unix.create_process</code> and related functions.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><p>accessors</p><div class="odoc-spec"><div class="spec value" id="val-pid" class="anchored"><a href="#val-pid" class="anchor"></a><code><span><span class="keyword">val</span> pid : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../core/Core/Pid/index.html#type-t">Core.Pid.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-stdin" class="anchored"><a href="#val-stdin" class="anchor"></a><code><span><span class="keyword">val</span> stdin : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Writer/index.html#type-t">Writer.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-stdout" class="anchored"><a href="#val-stdout" class="anchor"></a><code><span><span class="keyword">val</span> stdout : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Reader/index.html#type-t">Reader.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-stderr" class="anchored"><a href="#val-stderr" class="anchor"></a><code><span><span class="keyword">val</span> stderr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Reader/index.html#type-t">Reader.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-env" class="anchored"><a href="#type-env" class="anchor"></a><code><span><span class="keyword">type</span> env</span><span> = <a href="../../../core_unix/Core_unix/index.html#type-env">Core_unix.env</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_env" class="anchored"><a href="#val-sexp_of_env" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_env : <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-env_of_sexp" class="anchored"><a href="#val-env_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> env_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-env">env</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-create" class="anchored"><a href="#type-create" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a create</span></span><span> =
  <span>?argv0:string <span class="arrow">&#45;&gt;</span></span>
  <span>?buf_len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?env:<a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?prog_search_path:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?stdin:string <span class="arrow">&#45;&gt;</span></span>
  <span>?working_dir:string <span class="arrow">&#45;&gt;</span></span>
  <span>?setpgid:<a href="../../../core_unix/Core_unix/Pgid/index.html#type-t">Core_unix.Pgid.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>prog:string <span class="arrow">&#45;&gt;</span></span>
  <span>args:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>create ~prog ~args ()</code> uses <code>Core_unix.create_process_env</code> to create a child process that runs the executable <code>prog</code> with <code>args</code> as arguments.</p><p>This creates pipes to communicate with the child process's <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>. The caller is responsible for closing all these pipes. A lot of calls in the <code>Reader</code> module will close the underlying fd (e.g. iterating on <code>Reader.pipe</code>). You likely will have to explicitly call <code>Writer.close</code> on the <code>stdin</code> writer unless you call <code>collect_output_and_wait</code>.</p><p>Unlike <code>exec</code>, <code>args</code> should not include <code>prog</code> as the first argument.</p><p>If <code>buf_len</code> is supplied, it determines the size of the reader and writer buffers used to communicate with the child process's <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.</p><p>If <code>stdin</code> is supplied, then the writer to the child's stdin will have <code>~raise_when_consumer_leaves:false</code> and <code>~buffer_age_limit:`Unlimited</code>, which makes it more robust.</p><p><code>env</code> specifies the environment of the child process.</p><p>If <code>working_dir</code> is supplied, then the child process will <code>chdir()</code> there before calling <code>exec()</code>.</p><p>If <code>argv0</code> is given, it is used (instead of <code>prog</code>) as the first element of the <code>argv</code> array passed to <code>exec</code>.</p><p><code>create</code> returns <code>Error</code> if it is unable to create the child process. This can happen in any number of situations (unable to fork, unable to create the pipes, unable to cd to <code>working_dir</code>, unable to <code>exec</code> etc.). <code>create</code> does not return <code>Error</code> if the binary exits with non-zero exit code; instead, it returns <code>OK t</code>, where <code>wait t</code> returns an <code>Error</code>.</p><p>See <code>Core_unix.create_process_env</code> for more details.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span><a href="#type-t">t</a> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="#type-create">create</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create_exn" class="anchored"><a href="#val-create_exn" class="anchor"></a><code><span><span class="keyword">val</span> create_exn : <span><a href="#type-t">t</a> <a href="#type-create">create</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-wait" class="anchored"><a href="#val-wait" class="anchor"></a><code><span><span class="keyword">val</span> wait : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../core_unix/Core_unix/Exit_or_signal/index.html#type-t">Core_unix.Exit_or_signal.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>wait t = Unix.waitpid (pid t)</code>. <code>wait</code>'s result becomes determined when the child process terminates, via exit or signal. <code>wait</code> does not touch <code>stdin</code>, <code>stdout</code> or <code>stderr</code>. The caller should ensure that <code>stdout</code> and <code>stderr</code> are being drained in the background to avoid the child process blocking on a write due to pushback. See <code>collect_output_and_wait</code> for a higher-level alternative that handles this.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Output" class="anchored"><a href="#module-Output" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Output/index.html">Output</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-collect_output_and_wait" class="anchored"><a href="#val-collect_output_and_wait" class="anchor"></a><code><span><span class="keyword">val</span> collect_output_and_wait : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Output/index.html#type-t">Output.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>collect_output_and_wait t</code> closes <code>stdin t</code> and then begins collecting the output produced on <code>t</code>'s <code>stdout</code> and <code>stderr</code>, continuing to collect output until <code>t</code> terminates and the pipes for <code>stdout</code> and <code>stderr</code> are closed. Usually when <code>t</code> terminates, the pipes are closed; however, <code>t</code> could fork other processes which survive after <code>t</code> terminates and in turn keep the pipes open -- <code>collect_output_and_wait</code> will not become determined until both pipes are closed in all descendant processes.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-run" class="anchored"><a href="#type-run" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a run</span></span><span> =
  <span>?accept_nonzero_exit:<span>int list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?argv0:string <span class="arrow">&#45;&gt;</span></span>
  <span>?env:<a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?prog_search_path:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?stdin:string <span class="arrow">&#45;&gt;</span></span>
  <span>?working_dir:string <span class="arrow">&#45;&gt;</span></span>
  <span>prog:string <span class="arrow">&#45;&gt;</span></span>
  <span>args:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>run</code> <code>create</code>s a process, feeds it <code>stdin</code> if provided, and <code>wait</code>s for it to complete. If the process exits with an acceptable status, then <code>run</code> returns its stdout. If the process exits unacceptably, then <code>run</code> returns an error indicating what went wrong that includes stdout and stderr.</p><p>Acceptable statuses are zero, and any nonzero values specified in <code>accept_nonzero_exit</code>.</p><p>Some care is taken so that an error displays nicely as a sexp---in particular, if the child's output can already be parsed as a sexp, then it will display as a sexp (rather than a sexp embedded in a string). Also, if the output isn't a sexp, it will be split on newlines into a list of strings, so that it displays on multiple lines rather than a single giant line with embedded &quot;\n&quot;'s.</p><p><code>run_lines</code> is like <code>run</code> but returns the lines of stdout as a string list, using <code>String.split_lines</code>.</p><p><code>run_expect_no_output</code> is like <code>run</code> but expects the command to produce no output, and returns an error if the command does produce output.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run" class="anchored"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span><span>string <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="#type-run">run</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-run_exn" class="anchored"><a href="#val-run_exn" class="anchor"></a><code><span><span class="keyword">val</span> run_exn : <span>string <a href="#type-run">run</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-run_lines" class="anchored"><a href="#val-run_lines" class="anchor"></a><code><span><span class="keyword">val</span> run_lines : <span><span><span>string list</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="#type-run">run</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-run_lines_exn" class="anchored"><a href="#val-run_lines_exn" class="anchor"></a><code><span><span class="keyword">val</span> run_lines_exn : <span><span>string list</span> <a href="#type-run">run</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-run_expect_no_output" class="anchored"><a href="#val-run_expect_no_output" class="anchor"></a><code><span><span class="keyword">val</span> run_expect_no_output : <span><span>unit <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="#type-run">run</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-run_expect_no_output_exn" class="anchored"><a href="#val-run_expect_no_output_exn" class="anchor"></a><code><span><span class="keyword">val</span> run_expect_no_output_exn : <span>unit <a href="#type-run">run</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-collect" class="anchored"><a href="#type-collect" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a collect</span></span><span> =
  <span>?accept_nonzero_exit:<span>int list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span></code></div><div class="spec-doc"><p><code>collect_stdout_and_wait</code> and <code>collect_stdout_lines_and_wait</code> are like <code>run</code> and <code>run_lines</code> but work from an existing process instead of creating a new one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-collect_stdout_and_wait" class="anchored"><a href="#val-collect_stdout_and_wait" class="anchor"></a><code><span><span class="keyword">val</span> collect_stdout_and_wait : <span><span>string <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="#type-collect">collect</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-collect_stdout_and_wait_exn" class="anchored"><a href="#val-collect_stdout_and_wait_exn" class="anchor"></a><code><span><span class="keyword">val</span> collect_stdout_and_wait_exn : <span>string <a href="#type-collect">collect</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-collect_stdout_lines_and_wait" class="anchored"><a href="#val-collect_stdout_lines_and_wait" class="anchor"></a><code><span><span class="keyword">val</span> collect_stdout_lines_and_wait : <span><span><span>string list</span> <a href="../../../core/Core/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="#type-collect">collect</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-collect_stdout_lines_and_wait_exn" class="anchored"><a href="#val-collect_stdout_lines_and_wait_exn" class="anchor"></a><code><span><span class="keyword">val</span> collect_stdout_lines_and_wait_exn : <span><span>string list</span> <a href="#type-collect">collect</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-send_signal" class="anchored"><a href="#val-send_signal" class="anchor"></a><code><span><span class="keyword">val</span> send_signal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../core/Core/Signal/index.html#type-t">Core.Signal.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Sends a signal to this process. This is safe to call concurrently with <code>wait t</code>, even if the Pid is reused after the process died.</p><p>If the process was already terminated, the call succeeds and silently does nothing, regardless of whether or not the process was waited for.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-send_signal_compat" class="anchored"><a href="#val-send_signal_compat" class="anchor"></a><code><span><span class="keyword">val</span> send_signal_compat : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../core/Core/Signal/index.html#type-t">Core.Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span>[ `Ok <span>| `No_such_process</span> ]</span></span></code></div><div class="spec-doc"><p>Similar to <code>send_signal</code>, but additionally reports if a signal was actually sent, or a process was already terminated and waited for.</p><p>Note that if you never called <code>wait</code> on this process, you will always get <code>`Ok</code>, which can be surprising. This function is exposed for compatibility with the code that used <code>Signal_unix.send</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-send_signal_compat_exn" class="anchored"><a href="#val-send_signal_compat_exn" class="anchor"></a><code><span><span class="keyword">val</span> send_signal_compat_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../core/Core/Signal/index.html#type-t">Core.Signal.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Similar to <code>send_signal_compat</code>, but raises an exception on <code>`No_such_process</code>. Used to migrate the code that uses <code>Signal_unix.send_exn</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Lines_or_sexp" class="anchored"><a href="#module-Lines_or_sexp" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lines_or_sexp/index.html">Lines_or_sexp</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Lines_or_sexp</code> is useful for rendering a string nicely in a sexp, avoiding quoting if the string is multi-line or was produced by converting a sexp to a string. <code>Output.sexp_of_t</code> uses <code>Lines_or_sexp</code> to nicely render stdout and stderr of a child process.</p></div></div></div></body></html>