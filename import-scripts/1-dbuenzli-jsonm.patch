diff --git b/vendor/dbuenzli-jsonm/doc/index.mld a/vendor/dbuenzli-jsonm/doc/index.mld
new file mode 100644
index 0000000..82f1df0
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/doc/index.mld
@@ -0,0 +1,11 @@
+{0 Jsonm {%html: <span class="version">%%VERSION%%</span>%}}
+
+Jsonm is a non-blocking streaming codec to decode and encode the JSON
+data format. It can process JSON text without blocking on IO and
+without a complete in-memory representation of the data.
+
+{1:api API}
+
+{!modules:
+Jsonm
+}
diff --git b/vendor/dbuenzli-jsonm/dune-project a/vendor/dbuenzli-jsonm/dune-project
new file mode 100644
index 0000000..42c0c16
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/dune-project
@@ -0,0 +1 @@
+(lang dune 1.10)
diff --git b/vendor/dbuenzli-jsonm/opam a/vendor/dbuenzli-jsonm/opam
new file mode 100644
index 0000000..594aff8
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/opam
@@ -0,0 +1,16 @@
+opam-version: "2.0"
+maintainer: "Daniel BÃ¼nzli <daniel.buenzl i@erratique.ch>"
+authors: ["The jsonm programmers"]
+homepage: "https://erratique.ch/software/jsonm"
+doc: "https://erratique.ch/software/jsonm/doc/Jsonm"
+dev-repo: "git+https://erratique.ch/repos/jsonm.git"
+bug-reports: "https://github.com/dbuenzli/jsonm/issues"
+tags: [ "json" "codec" "org:erratique" ]
+license: "ISC"
+depends: [
+  "ocaml" {>= "4.05.0"}
+  "ocamlfind" {build}
+  "ocamlbuild" {build}
+  "topkg" {build & >= "1.0.1"}
+  "uutf" { >= "1.0.0" }]
+build:[[ "ocaml" "pkg/pkg.ml" "build" "--pinned" "%{pinned}%" ]]
\ No newline at end of file
diff --git b/vendor/dbuenzli-jsonm/pkg/META a/vendor/dbuenzli-jsonm/pkg/META
new file mode 100644
index 0000000..cbdfc02
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/pkg/META
@@ -0,0 +1,7 @@
+description = "Non-blocking streaming JSON codec"
+version = "%%VERSION_NUM%%"
+requires = "uutf"
+archive(byte) = "jsonm.cma"
+archive(native) = "jsonm.cmxa"
+plugin(byte) = "jsonm.cma"
+plugin(native) = "jsonm.cmxs"
diff --git b/vendor/dbuenzli-jsonm/pkg/pkg.ml a/vendor/dbuenzli-jsonm/pkg/pkg.ml
new file mode 100755
index 0000000..db526e1
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/pkg/pkg.ml
@@ -0,0 +1,15 @@
+#!/usr/bin/env ocaml
+#use "topfind"
+#require "topkg"
+open Topkg
+
+let () =
+  Pkg.describe "jsonm" @@ fun c ->
+  Ok [ Pkg.mllib "src/jsonm.mllib";
+       Pkg.bin "test/jsontrip";
+       Pkg.doc "test/examples.ml";
+       Pkg.doc "test/jtree.ml";
+       Pkg.doc "doc/index.mld" ~dst:"odoc-pages/index.mld";
+       Pkg.test "test/test";
+       Pkg.test ~run:false "test/examples";
+       Pkg.test ~run:false "test/jtree"; ]
diff --git b/vendor/dbuenzli-jsonm/src/dune a/vendor/dbuenzli-jsonm/src/dune
new file mode 100644
index 0000000..eb090b2
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/src/dune
@@ -0,0 +1 @@
+(library (name jsonm) (public_name jsonm))
diff --git b/vendor/dbuenzli-jsonm/test/examples.ml a/vendor/dbuenzli-jsonm/test/examples.ml
new file mode 100644
index 0000000..f8368b4
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/test/examples.ml
@@ -0,0 +1,70 @@
+(* Examples form the documentation (see also jtree.ml), this code is in public
+   domain.  *)
+
+(* Trip *)
+
+let trip ?encoding ?minify
+    (src : [`Channel of in_channel | `String of string])
+    (dst : [`Channel of out_channel | `Buffer of Buffer.t])
+  =
+  let rec loop d e = match Jsonm.decode d with
+  | `Lexeme _ as v -> ignore (Jsonm.encode e v); loop d e
+  | `End -> ignore (Jsonm.encode e `End); `Ok
+  | `Error err -> `Error (Jsonm.decoded_range d, err)
+  | `Await -> assert false
+  in
+  let d = Jsonm.decoder ?encoding src in
+  let e = Jsonm.encoder ?minify dst in
+  loop d e
+
+let trip_fd ?encoding ?minify
+    (fdi : Unix.file_descr)
+    (fdo : Unix.file_descr)
+  =
+  let rec encode fd s e v = match Jsonm.encode e v with `Ok -> ()
+  | `Partial ->
+      let rec unix_write fd s j l =
+        let rec write fd s j l = try Unix.single_write fd s j l with
+        | Unix.Unix_error (Unix.EINTR, _, _) -> write fd s j l
+        in
+        let wc = write fd s j l in
+        if wc < l then unix_write fd s (j + wc) (l - wc) else ()
+      in
+      unix_write fd s 0 (Bytes.length s - Jsonm.Manual.dst_rem e);
+      Jsonm.Manual.dst e s 0 (Bytes.length s);
+      encode fd s e `Await
+  in
+  let rec loop fdi fdo ds es d e = match Jsonm.decode d with
+  | `Lexeme _ as v -> encode fdo es e v; loop fdi fdo ds es d e
+  | `End -> encode fdo es e `End; `Ok
+  | `Error err -> `Error (Jsonm.decoded_range d, err)
+  | `Await ->
+      let rec unix_read fd s j l = try Unix.read fd s j l with
+      | Unix.Unix_error (Unix.EINTR, _, _) -> unix_read fd s j l
+      in
+      let rc = unix_read fdi ds 0 (Bytes.length ds) in
+      Jsonm.Manual.src d ds 0 rc; loop fdi fdo ds es d e
+  in
+  let ds = Bytes.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
+  let es = Bytes.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
+  let d = Jsonm.decoder ?encoding `Manual in
+  let e = Jsonm.encoder ?minify `Manual in
+  Jsonm.Manual.dst e es 0 (Bytes.length es);
+  loop fdi fdo ds es d e
+
+(* Member selection *)
+
+let memsel ?encoding names
+    (src : [`Channel of in_channel | `String of string])
+  =
+  let rec loop acc names d = match Jsonm.decode d with
+  | `Lexeme (`Name n) when List.mem n names ->
+      begin match Jsonm.decode d with
+      | `Lexeme (`String s) -> loop (s :: acc) names d
+      | _ -> loop acc names d
+      end
+  | `Lexeme _ | `Error _ -> loop acc names d
+  | `End -> List.rev acc
+  | `Await -> assert false
+  in
+  loop [] names (Jsonm.decoder ?encoding src)
diff --git b/vendor/dbuenzli-jsonm/test/jsontrip.ml a/vendor/dbuenzli-jsonm/test/jsontrip.ml
new file mode 100644
index 0000000..5ad6a18
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/test/jsontrip.ml
@@ -0,0 +1,385 @@
+(*---------------------------------------------------------------------------
+   Copyright (c) 2012 The jsonm programmers. All rights reserved.
+   Distributed under the ISC license, see terms at the end of the file.
+  ---------------------------------------------------------------------------*)
+
+let pr = Format.fprintf
+let pr_range ppf ((l0, c0), (l1, c1)) = pr ppf "%d.%d-%d.%d" l0 c0 l1 c1
+let pr_decode ppf inf d v = pr ppf "%s:%a: %a@\n@?"
+  inf pr_range (Jsonm.decoded_range d) Jsonm.Uncut.pp_decode v
+
+let exec = Filename.basename Sys.executable_name
+let log f = Format.eprintf ("%s: " ^^ f ^^ "@?") exec
+let log_error inf d e = Format.eprintf "%s:%a: %a@\n@?"
+  inf pr_range (Jsonm.decoded_range d) Jsonm.pp_error e
+
+(* IO tools *)
+
+let io_buffer_size = 65536                          (* IO_BUFFER_SIZE 4.0.0 *)
+let unix_buffer_size = 65536                      (* UNIX_BUFFER_SIZE 4.0.0 *)
+
+let rec unix_read fd s j l = try Unix.read fd s j l with
+| Unix.Unix_error (Unix.EINTR, _, _) -> unix_read fd s j l
+
+let rec unix_write fd s j l =
+  let rec write fd s j l = try Unix.single_write fd s j l with
+  | Unix.Unix_error (Unix.EINTR, _, _) -> write fd s j l
+  in
+  let wc = write fd s j l in
+  if wc < l then unix_write fd s (j + wc) (l - wc) else ()
+
+let string_of_channel use_unix ic =
+  let b = Buffer.create unix_buffer_size in
+  let input, s =
+    if use_unix
+    then unix_read (Unix.descr_of_in_channel ic), Bytes.create unix_buffer_size
+    else input ic, Bytes.create io_buffer_size
+  in
+  let rec loop b input s =
+    let rc = input s 0 (Bytes.length s) in
+    if rc = 0 then Buffer.contents b else
+    let us = Bytes.unsafe_to_string s in
+    (Buffer.add_substring b us 0 rc; loop b input s)
+  in
+  loop b input s
+
+let string_to_channel use_unix oc s = match use_unix with
+| false -> output_string oc s
+| true ->
+    let s = Bytes.unsafe_of_string s in
+    unix_write (Unix.descr_of_out_channel oc) s 0 (Bytes.length s)
+
+let dst_for sout = if sout then `Buffer (Buffer.create 512) else `Channel stdout
+let src_for inf sin use_unix =
+  try
+    let ic = if inf = "-" then stdin else open_in inf in
+    if sin then `String (string_of_channel use_unix ic) else `Channel ic
+  with Sys_error e -> log "%s\n" e; exit 1
+
+let close_src src =
+  try match src with `Channel ic when ic <> stdin -> close_in ic | _ -> () with
+  | Sys_error e -> log "%s\n" e; exit 1
+
+let src_for_unix inf =
+  try if inf = "-" then Unix.stdin else Unix.(openfile inf [O_RDONLY] 0) with
+  | Unix.Unix_error (e, _, v) -> log "%s: %s\n" (Unix.error_message e) v; exit 1
+
+let close_src_unix fd = try if fd <> Unix.stdin then Unix.close fd with
+| Unix.Unix_error (e, _, v) -> log "%s: %s\n" (Unix.error_message e) v; exit 1
+
+let rec encode_unix encode fd s e v = match encode e v with `Ok -> ()
+| `Partial ->
+    unix_write fd s 0 (Bytes.length s - Jsonm.Manual.dst_rem e);
+    Jsonm.Manual.dst e s 0 (Bytes.length s);
+    encode_unix encode fd s e `Await
+
+(* Dump *)
+
+let dump_ inf encoding uncut src =
+  let decode = if uncut then Jsonm.Uncut.decode else Jsonm.decode in
+  let rec loop decode d = match decode d with `Await -> assert false
+  | v -> pr_decode Format.std_formatter inf d v; if v <> `End then loop decode d
+  in
+  loop decode (Jsonm.decoder ?encoding src);
+  close_src src
+
+let dump_unix inf encoding uncut usize fd =
+  let decode = if uncut then Jsonm.Uncut.decode else Jsonm.decode in
+  let rec loop decode fd s d = match decode d with
+  | `Await ->
+      let rc = unix_read fd s 0 (Bytes.length s) in
+      Jsonm.Manual.src d s 0 rc; loop decode fd s d
+  | v ->
+      pr_decode Format.std_formatter inf d v;
+      if v <> `End then loop decode fd s d
+  in
+  loop decode fd (Bytes.create usize) (Jsonm.decoder ?encoding `Manual);
+  close_src_unix fd
+
+let dump inf sin use_unix usize ie uncut =
+  if sin || not use_unix then dump_ inf ie uncut (src_for inf sin use_unix)
+  else dump_unix inf ie uncut usize (src_for_unix inf)
+
+(* Guess encoding *)
+
+let guess inf =
+  let d = Jsonm.decoder (src_for inf false false) in
+  ignore (Jsonm.decode d);
+  Format.printf "%s@." (Uutf.encoding_to_string (Jsonm.decoder_encoding d))
+
+(* Decode only *)
+
+let decode_ inf encoding uncut src =
+  let decode = if uncut then Jsonm.Uncut.decode else Jsonm.decode in
+  let rec loop decode d = match decode d with
+  | `Lexeme _ ->  loop decode d
+  | `End -> ()
+  | `Comment _ | `White _  -> loop decode d
+  | `Error e -> log_error inf d e; loop decode d
+  | `Await -> assert false
+  in
+  loop decode (Jsonm.decoder ?encoding src)
+
+let decode_unix inf encoding uncut usize fd =
+  let decode = if uncut then Jsonm.Uncut.decode else Jsonm.decode in
+  let rec loop decode fd s d = match decode d with
+  | `Lexeme _ -> loop decode fd s d
+  | `End -> ()
+  | `Comment _ | `White _  -> loop decode fd s d
+  | `Error e -> log_error inf d e; loop decode fd s d
+  | `Await ->
+      let rc = unix_read fd s 0 (Bytes.length s) in
+      Jsonm.Manual.src d s 0 rc; loop decode fd s d
+  in
+  loop decode fd (Bytes.create usize) (Jsonm.decoder ?encoding `Manual)
+
+let decode inf sin use_unix usize ie uncut =
+  if sin || not use_unix then decode_ inf ie uncut (src_for inf use_unix sin)
+  else decode_unix inf ie uncut usize Unix.stdin
+
+(* Random encode only *)
+
+let r_ascii_letter () =
+  Uchar.unsafe_of_int (0x0061 (* a *) + Random.int 26)
+
+let r_general_scripts () =
+  Uchar.unsafe_of_int (Random.int 0x2000 (* < U+2000 *))
+
+let max_rint = 9007199254740993L (* 2 ^ 53 + 1 *)
+let r_int () =    (* random integer exactly representable by an OCaml float. *)
+  let i = Random.int64 max_rint in
+  Int64.to_float (if Random.bool () then Int64.neg i else i)
+
+let r_float () =                           (* generate all string notations. *)
+  let f = if (Random.bool ()) then Random.float 1e-5 else Random.float 1.5e12 in
+  if (Random.bool ()) then ~-. f else f
+
+let r_name buf maxs =
+  Buffer.clear buf;
+  for i = 0 to Random.int (maxs + 1)
+  do Uutf.Buffer.add_utf_8 buf (r_ascii_letter ()) done;
+  `Name (Buffer.contents buf)
+
+let r_string buf maxs =
+  Buffer.clear buf;
+  for i = 0 to Random.int (maxs + 1)
+  do Uutf.Buffer.add_utf_8 buf (r_general_scripts ()) done;
+  `String (Buffer.contents buf)
+
+let r_comment buf =
+  Buffer.clear buf;
+  let style = if Random.bool () then `M else `S in
+  for i = 0 to Random.int 64 do
+    let c = r_general_scripts () in
+    let ci = Uchar.to_int c in
+    (* avoid any // and */ sequence and control chars *)
+    if ci != 0x002F (* / *) && ci > 0x001F then Uutf.Buffer.add_utf_8 buf c
+  done;
+  `Comment (style, Buffer.contents buf)
+
+let r_white buf =
+  Buffer.clear buf;
+  for i = 0 to Random.int 3 do match Random.int 100 with
+  | n when n < 90 -> Buffer.add_char buf ' '
+  | n when n < 94 -> Buffer.add_char buf '\t'
+  | n when n < 98 -> Buffer.add_char buf '\n'
+  | n when n < 100 -> Buffer.add_char buf '\r'
+  | n -> assert false
+  done;
+  `White (Buffer.contents buf)
+
+let rec r_value k enc buf count ri maxd maxl maxs =
+  let kontinue () = k enc buf (count - 1) ri maxd maxl maxs in
+  match (if maxd = 0 then Random.int 4 else Random.int 6) with
+  | 0 -> enc `Null; kontinue ()
+  | 1 -> enc (`Bool (Random.bool ())); kontinue ()
+  | 2 -> enc (`Float (if ri then r_int () else r_float ())); kontinue ()
+  | 3 -> enc (r_string buf maxs); kontinue ()
+  | 4 | 5 ->
+      let bound = Random.int maxl + 1 in
+      r_json bound k enc buf (count - 1) ri maxd maxl maxs
+  | n -> assert false
+
+and r_obj_ms bound k enc buf count ri maxd maxl maxs =
+  if count = 0 || bound = 0
+  then (enc `Oe; k enc buf count ri (maxd + 1) maxl maxs) else
+  begin
+    enc (r_name buf maxs);
+    r_value (r_obj_ms (bound - 1) k) enc buf count ri maxd maxl maxs
+  end
+
+and r_arr_vs bound k enc buf count ri maxd maxl maxs =
+  if count = 0 || bound = 0
+  then (enc `Ae; k enc buf count ri (maxd + 1) maxl maxs)
+  else r_value (r_arr_vs (bound - 1) k) enc buf count ri maxd maxl maxs
+
+and r_json bound k enc buf count ri maxd maxl maxs =
+  if Random.bool ()
+  then (enc `Os; r_obj_ms bound k enc buf count ri (maxd - 1) maxl maxs)
+  else (enc `As; r_arr_vs bound k enc buf count ri (maxd - 1) maxl maxs)
+
+let r_json_text enc buf vcount ri maxd maxl maxs =
+  let stop _ _ _ _ _ _ _ = enc `End in
+  let encl l = enc (`Lexeme l) in
+  r_json max_int stop encl buf (vcount - 1) ri maxd maxl maxs
+
+let r_uncut enc buf = match Random.int 100 with
+| n when n < 50 -> ()
+| n when n < 90 -> enc (r_white buf)
+| n when n < 100 -> enc (r_comment buf)
+| n -> assert false
+
+let encode_f buf uncut minify dst =
+  let e = Jsonm.encoder ~minify dst in
+  if not uncut then (fun v -> ignore (Jsonm.encode e v)) else
+  let enc v = ignore (Jsonm.Uncut.encode e v) in
+  fun v -> r_uncut enc buf; enc v; r_uncut enc buf
+
+let encode_f_unix usize buf uncut minify fd =
+  let e, s = Jsonm.encoder ~minify `Manual, Bytes.create usize in
+  Jsonm.Manual.dst e s 0 (Bytes.length s);
+  if not uncut then (fun v -> encode_unix Jsonm.encode fd s e v) else
+  let enc v = encode_unix Jsonm.Uncut.encode fd s e v in
+  fun v -> r_uncut enc buf; enc v; r_uncut enc buf
+
+let r_encode sout use_unix usize uncut indent rseed rcount ri maxd maxl maxs =
+  let dst = dst_for sout in
+  let buf = Buffer.create maxs in
+  let encode_f =
+    if sout || not use_unix then encode_f buf uncut indent dst else
+    encode_f_unix usize buf uncut indent Unix.stdout
+  in
+  log "Encoding random JSON text with seed %d\n" rseed;
+  Random.init rseed; r_json_text encode_f buf rcount ri maxd maxl maxs;
+  match dst with `Channel _ -> ()
+  | `Buffer b -> string_to_channel use_unix stdout (Buffer.contents b)
+
+(* Trip *)
+
+let trip_ inf uncut minify encoding src dst =
+  let decode = if uncut then Jsonm.Uncut.decode else Jsonm.decode in
+  let rec loop decode d e = match decode d with
+  | `Lexeme _ as v -> ignore (Jsonm.encode e v); loop decode d e
+  | `End -> ignore (Jsonm.encode e `End)
+  | `Comment _ | `White _  as v ->
+      if not minify then ignore (Jsonm.Uncut.encode e v); loop decode d e
+  | `Error err -> log_error inf d err
+  | `Await -> assert false
+  in
+  let d = Jsonm.decoder src in
+  let e = Jsonm.encoder ~minify:(minify || uncut) dst in
+  loop decode d e; close_src src
+
+let trip_unix inf usize uncut minify encoding fdi fdo =
+  let decode = if uncut then Jsonm.Uncut.decode else Jsonm.decode in
+  let rec loop decode fdi fdo ds es d e = match decode d with
+  | `Lexeme _ as v ->
+      encode_unix Jsonm.encode fdo es e v; loop decode fdi fdo ds es d e
+  | `End -> encode_unix Jsonm.encode fdo es e `End
+  | `Comment _ | `White _ as v ->
+      if not minify then ignore (encode_unix Jsonm.Uncut.encode fdo es e v);
+      loop decode fdi fdo ds es d e
+  | `Error err -> log_error inf d err
+  | `Await ->
+      let rc = unix_read fdi ds 0 (Bytes.length ds) in
+      Jsonm.Manual.src d ds 0 rc; loop decode fdi fdo ds es d e
+  in
+  let d, ds = Jsonm.decoder ?encoding `Manual, Bytes.create usize in
+  let e, es = Jsonm.encoder ~minify `Manual, Bytes.create usize in
+  Jsonm.Manual.dst e es 0 (Bytes.length es);
+  loop decode fdi fdo ds es d e; close_src_unix fdi
+
+let trip inf sin sout use_unix usize ie uncut minify =
+  let src = src_for inf use_unix sin in
+  let dst = dst_for sout in
+  if sin || sout || not use_unix then trip_ inf uncut minify ie src dst else
+  trip_unix inf usize uncut minify ie (src_for_unix inf) Unix.stdout;
+  match dst with `Channel _ -> ()
+  | `Buffer b -> string_to_channel use_unix stdout (Buffer.contents b)
+
+let main () =
+ let usage = Printf.sprintf
+    "Usage: %s [OPTION]... [INFILE]\n\
+     \ Recode JSON from stdin to stdout.\n\
+     Options:" exec
+  in
+  let cmd = ref `Trip in
+  let set_cmd v () = cmd := v in
+  let inf = ref "-" in
+  let set_inf f =
+    if !inf <> "-" then raise (Arg.Bad "only one file can be specified") else
+    inf := f
+  in
+  let ie = ref None in
+  let ie_fun e = match Uutf.encoding_of_string e with
+  | None | Some (`US_ASCII | `ISO_8859_1) ->
+    log "unsupported input encoding '%s', using UTF-8\n" e
+  | (Some #Jsonm.encoding) as enc -> ie := enc
+  in
+  let uncut = ref false in
+  let minify = ref true in
+  let sin = ref false in
+  let sout = ref false in
+  let use_unix = ref false in
+  let usize = ref unix_buffer_size in
+  let rseed = ref (Random.self_init (); Random.int (1 lsl 30 - 1)) in
+  let rcount = ref 560_000 in (* params for ~10Mo of JSON. *)
+  let rint = ref false in
+  let maxd = ref 5 in
+  let maxl = ref 20 in
+  let maxs = ref 15 in
+  let nat s r v = if v > 0 then r := v else log "%s must be > 0, ignored\n" s in
+  let options = [
+    "-dump", Arg.Unit (set_cmd `Dump),
+    " Dump lexemes and their position, one per line";
+    "-guess", Arg.Unit (set_cmd `Guess), " Only guess the encoding";
+    "-dec", Arg.Unit (set_cmd `Decode), " Decode only, no encoding";
+    "-enc", Arg.Unit (set_cmd `Encode), " Encode only (random), no decoding";
+    "-ie", Arg.String ie_fun,
+    "<enc> Input encoding: UTF-8, UTF-16, UTF-16BE or UTF-16LE";
+    "-uncut", Arg.Set uncut,
+    " Use the uncut codec (allows comments in the input)";
+    "-pp", Arg.Clear minify, " Pretty print output (minified by default)";
+    "-sin", Arg.Set sin, " Input as string and decode the string";
+    "-sout", Arg.Set sout, " Encode as string and output the string";
+    "-unix", Arg.Set use_unix, " Use Unix IO";
+    "-usize", Arg.Int (nat "-usize" usize),
+    "<int> Unix IO buffer sizes in bytes";
+    "-rseed", Arg.Int (nat "-rseed" rseed), "<int> Random seed";
+    "-rcount", Arg.Int (nat "-rcount" rcount),
+    "<int> Number of JSON values in random JSON text";
+    "-rint", Arg.Set rint, " Generate only integer JSON numbers (no floats)";
+    "-maxd", Arg.Int (nat "-maxd" maxd),
+    "<int> Maximal depth in random JSON text";
+    "-maxl", Arg.Int (nat "-maxl" maxl),
+    "<int> Maximal inner array and object length in random JSON";
+    "-maxs", Arg.Int (nat "-maxs" maxs),
+    "<int> Maximal string length in random JSON text"; ]
+  in
+  Arg.parse (Arg.align options) set_inf usage;
+  match !cmd with
+  | `Dump -> dump !inf !sin !use_unix !usize !ie !uncut
+  | `Guess -> guess !inf
+  | `Trip -> trip !inf !sin !sout !use_unix !usize !ie !uncut !minify
+  | `Decode -> decode !inf !sin !use_unix !usize !ie !uncut
+  | `Encode ->
+      r_encode !sout !use_unix !usize !uncut !minify !rseed !rcount
+        !rint !maxd !maxl !maxs
+
+let () = main ()
+
+(*---------------------------------------------------------------------------
+   Copyright (c) 2012 The jsonm programmers
+
+   Permission to use, copy, modify, and/or distribute this software for any
+   purpose with or without fee is hereby granted, provided that the above
+   copyright notice and this permission notice appear in all copies.
+
+   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  ---------------------------------------------------------------------------*)
diff --git b/vendor/dbuenzli-jsonm/test/jtree.ml a/vendor/dbuenzli-jsonm/test/jtree.ml
new file mode 100644
index 0000000..4074a43
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/test/jtree.ml
@@ -0,0 +1,74 @@
+(* This code is in the public domain *)
+
+(* Generic JSON tree type *)
+
+type json =
+  [ `Null | `Bool of bool | `Float of float| `String of string
+  | `A of json list | `O of (string * json) list ]
+
+exception Escape of ((int * int) * (int * int)) * Jsonm.error
+
+let json_of_src ?encoding
+    (src : [`Channel of in_channel | `String of string])
+  =
+  let dec d = match Jsonm.decode d with
+  | `Lexeme l -> l
+  | `Error e -> raise (Escape (Jsonm.decoded_range d, e))
+  | `End | `Await -> assert false
+  in
+  let rec value v k d = match v with
+  | `Os -> obj [] k d  | `As -> arr [] k d
+  | `Null | `Bool _ | `String _ | `Float _ as v -> k v d
+  | _ -> assert false
+  and arr vs k d = match dec d with
+  | `Ae -> k (`A (List.rev vs)) d
+  | v -> value v (fun v -> arr (v :: vs) k) d
+  and obj ms k d = match dec d with
+  | `Oe -> k (`O (List.rev ms)) d
+  | `Name n -> value (dec d) (fun v -> obj ((n, v) :: ms) k) d
+  | _ -> assert false
+  in
+  let d = Jsonm.decoder ?encoding src in
+  try `JSON (value (dec d) (fun v _ -> v) d) with
+  | Escape (r, e) -> `Error (r, e)
+
+let json_to_dst ~minify
+    (dst : [`Channel of out_channel | `Buffer of Buffer.t ])
+    (json : json)
+  =
+  let enc e l = ignore (Jsonm.encode e (`Lexeme l)) in
+  let rec value v k e = match v with
+  | `A vs -> arr vs k e
+  | `O ms -> obj ms k e
+  | `Null | `Bool _ | `Float _ | `String _ as v -> enc e v; k e
+  and arr vs k e = enc e `As; arr_vs vs k e
+  and arr_vs vs k e = match vs with
+  | v :: vs' -> value v (arr_vs vs' k) e
+  | [] -> enc e `Ae; k e
+  and obj ms k e = enc e `Os; obj_ms ms k e
+  and obj_ms ms k e = match ms with
+  | (n, v) :: ms -> enc e (`Name n); value v (obj_ms ms k) e
+  | [] -> enc e `Oe; k e
+  in
+  let e = Jsonm.encoder ~minify dst in
+  let finish e = ignore (Jsonm.encode e `End) in
+  value json finish e
+
+let main () =
+  let exec = Filename.basename Sys.executable_name in
+  let usage = Printf.sprintf
+    "Usage: %s [OPTION]...\n\
+    \ Recode JSON from stdin to stdout via an in-memory tree representation.\n\
+     Options:" exec
+  in
+  let minify = ref true in
+  let options = [ "-pp", Arg.Clear minify, " Pretty print output"; ] in
+  let anon _ = raise (Arg.Bad "illegal argument") in
+  Arg.parse (Arg.align options) anon usage;
+  let minify = !minify in
+  match json_of_src (`Channel stdin) with
+  | `JSON j -> json_to_dst ~minify (`Channel stdout) j
+  | `Error (((l1, c1), (l2, c2)), e) ->
+      Format.eprintf "-:%d.%d-%d.%d: %a\n%!" l1 c1 l2 c2 Jsonm.pp_error e
+
+let () = main ()
diff --git b/vendor/dbuenzli-jsonm/test/test.ml a/vendor/dbuenzli-jsonm/test/test.ml
new file mode 100644
index 0000000..02af82c
--- /dev/null
+++ a/vendor/dbuenzli-jsonm/test/test.ml
@@ -0,0 +1,361 @@
+(*---------------------------------------------------------------------------
+   Copyright (c) 2012 The jsonm programmers. All rights reserved.
+   Distributed under the ISC license, see terms at the end of the file.
+  ---------------------------------------------------------------------------*)
+
+let str = Format.sprintf
+let log f = Format.printf (f ^^ "@?")
+let fail fmt =
+  let fail _ = failwith (Format.flush_str_formatter ()) in
+  Format.kfprintf fail Format.str_formatter fmt
+
+let encoder_invalid () =
+  log "Invalid encodes.\n";
+  let rec encode_seq e = function
+  | v :: vs -> ignore (Jsonm.Uncut.encode e v); encode_seq e vs
+  | [] -> ()
+  in
+  let seq ~invalid s =
+    let test ~minify =
+      let e = Jsonm.encoder ~minify (`Buffer (Buffer.create 256)) in
+      try encode_seq e s; assert (not invalid) with
+      | Invalid_argument _ as e -> if invalid then () else raise e
+    in
+    test ~minify:true; test ~minify:false
+  in
+  seq ~invalid:false [ `Lexeme `Null];
+  seq ~invalid:false [ `Lexeme (`Bool true)];
+  seq ~invalid:false [ `Lexeme (`Bool false)];
+  seq ~invalid:false [ `Lexeme (`Float 1.0)];
+  seq ~invalid:false [ `Lexeme (`String "bla")];
+  seq ~invalid:true  [ `Lexeme `Ae];
+  seq ~invalid:true  [ `Lexeme `Oe];
+  seq ~invalid:true [ `Lexeme (`Name "b")];
+  seq ~invalid:true [ `White "    "; `Lexeme `Oe];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme `Ae];
+  seq ~invalid:true [ `Comment (`S, "bla"); `Lexeme `Os; `Lexeme `Ae];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme `Null];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme (`Name "b"); `Lexeme (`Name "b")];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme (`Name "b"); `Lexeme `Ae];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme (`Name "b"); `Lexeme `Oe];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme (`Name "b"); `Lexeme `Ae];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme (`Name "b"); `Lexeme `Null;
+                      `Lexeme `Null; ];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme (`Name "b"); `Lexeme `Null;
+                      `Lexeme (`Name "c"); `Lexeme `Ae;];
+  seq ~invalid:true [ `Lexeme `As; `Lexeme (`Oe) ];
+  seq ~invalid:true [ `Lexeme `As; `Lexeme (`Name "b") ];
+  seq ~invalid:true [ `Lexeme `As; `Lexeme `Null; `Lexeme (`Name "b"); ];
+  seq ~invalid:true [ `Lexeme `As; `Lexeme `Ae; `Lexeme `As];
+  seq ~invalid:true [ `Lexeme `As; `Lexeme `Ae; `Lexeme `Null];
+  seq ~invalid:true [ `Lexeme `As; `Lexeme `Ae; `End; `Lexeme `As];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme `Oe; `Lexeme `Os];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme `Oe; `Lexeme `Null];
+  seq ~invalid:true [ `Lexeme `Os; `Lexeme `Oe; `End; `Lexeme `Os];
+  ()
+
+let encoder_escapes () =
+  log "Encoder escapes.\n";
+  let encode ascii sascii =
+    let b = Buffer.create 10 in
+    let e = Jsonm.encoder (`Buffer b) in
+    let enc v = ignore (Jsonm.encode e (`Lexeme v)) in
+    List.iter enc [ `As; `String (Printf.sprintf "%c" (Char.chr ascii)); `Ae ];
+    ignore (Jsonm.encode e `End);
+    let json = Buffer.contents b in
+    let exp = str "[\"%s\"]" sascii in
+    if json <> exp then fail "found: %s exp: %s" json exp
+  in
+  encode 0x22 "\\\"";
+  encode 0x5C "\\\\";
+  for i = 0x00 to 0x1F do
+    if i = 0x0A then encode i "\\n" else
+    encode i (str "\\u00%02X" i)
+  done;
+  ()
+
+let decoder_encoding_guess () =
+  log "Decoder encoding guesses.\n";
+  let test enc s =
+    let d = Jsonm.decoder (`String s) in
+    let enc' = (ignore (Jsonm.decode d); Jsonm.decoder_encoding d) in
+    if  enc' <> enc then
+    fail "found: %s exp: %s"
+      (Uutf.encoding_to_string enc') (Uutf.encoding_to_string enc)
+  in
+  test `UTF_8 "[]";
+  test `UTF_8 "{}";
+  test `UTF_16BE "\x00\x5B\x00\x5D";
+  test `UTF_16BE "\x00\x7B\x00\x7D";
+  test `UTF_16LE "\x5B\x00\x5D\x00";
+  test `UTF_16LE "\x7B\x00\x7D\x00";
+  ()
+
+let test_decode fnd exp =
+  if fnd <> exp then fail "found: %a expected: %a"
+  Jsonm.Uncut.pp_decode fnd Jsonm.Uncut.pp_decode exp
+
+let test_seq decode src seq =
+  let d = Jsonm.decoder (`String src) in
+  let rec loop d = function
+  | [] ->  if decode d <> `End then fail "decoder not at the `End"; ()
+  | v :: vs -> test_decode (decode d) v; loop d vs
+  in
+  loop d seq
+
+let arr seq = [`Lexeme `As] @ seq @ [`Lexeme `Ae; `End; `End; `End ]
+
+let decoder_comments () =
+  log "Decoder comments.\n";
+  let test (s,c) src = test_seq Jsonm.Uncut.decode src (arr [`Comment (s,c)]) in
+  let test_eoi v src = test_seq Jsonm.Uncut.decode  src
+    [`Lexeme `As; `Lexeme `Ae; v; `End];
+  in
+  test (`M, "bla") "[/*bla*/]";
+  test (`M, "b*") "[/*b**/]";
+  test (`M, "b** /") "[/*b** /*/]";
+  test (`M, "b** /") "[/*b** /*/]";
+  test (`M, "b***\n/") "[/*b***\n/*/]";
+  test (`S, "abcd") "[//abcd\n]";
+  test_eoi (`Comment (`S, "abcd")) "[]//abcd";
+  test_eoi (`Comment (`S, "abcd///* ")) "[]//abcd///* ";
+  test_eoi (`Comment (`M, " abcd ")) "[]/* abcd */";
+  test_eoi (`Comment (`M, " abcd ")) "[]/* abcd */";
+  test_eoi (`Error (`Unclosed `Comment)) "[]/* abcd ";
+  test_eoi (`Error (`Expected `Comment)) "[]/";
+  ()
+
+let decoder_escapes () =
+  log "Decoder escapes.\n";
+  let test str src = test_seq Jsonm.decode src (arr [`Lexeme (`String str)]) in
+  let test_ill ill str src = test_seq Jsonm.decode src
+    (arr [`Error (`Illegal_escape ill); `Lexeme (`String str)])
+  in
+  let not_esc_uchar u = `Not_esc_uchar (Uchar.of_int u) in
+  let not_hex_uchar u = `Not_hex_uchar (Uchar.of_int u) in
+  let s s = Printf.sprintf "[\"%s\"]" s in
+  test "<\">" (s "<\\\">");
+  test "<\\>" (s "<\\\\>");
+  test "</>" (s "<\\/>");
+  test "<\b>" (s "<\\b>");
+  test "<\x0C>" (s "<\\f>");
+  test "<\n>" (s "<\\n>");
+  test "<\r>" (s "<\\r>");
+  test "<\t>" (s "<\\t>");
+  test "<\xF0\x9D\x84\x9E><\xE6\xB0\xB4>" (s "<\\uD834\\uDd1E><\\u6C34>");
+  test_ill (not_esc_uchar 0x61) "<\xEF\xBF\xBD>" (s "<\\a>");
+  test_ill (not_esc_uchar 0x31) "<\xEF\xBF\xBD>" (s "<\\1>");
+  test_ill (not_esc_uchar 0xFFFD) "<\xEF\xBF\xBD>" (s "<\\\xEF\xBF\xBD>");
+  test_ill (not_hex_uchar 0x47) "<\xEF\xBF\xBDAF1>" (s "<\\uGAF1>");
+  test_ill (not_hex_uchar 0x47) "<\xEF\xBF\xBDF1>" (s "<\\uAGF1>");
+  test_ill (not_hex_uchar 0x67) "<\xEF\xBF\xBD1>" (s "<\\uAFg1>");
+  test_ill (not_hex_uchar 0x67) "<\xEF\xBF\xBD>" (s "<\\uAF1g>");
+  test_ill (`Not_lo_surrogate 0x6C34) "<\xEF\xBF\xBD>" (s "<\\uD834\\u6C34>");
+  test_ill (`Lone_hi_surrogate 0xD834) "<\xEF\xBF\xBDbla>" (s "<\\uD834bla>");
+  test_ill (`Lone_lo_surrogate 0xDD1E) "<\xEF\xBF\xBDbla>" (s "<\\uDd1Ebla>");
+  test_ill (`Lone_hi_surrogate 0xD834) "<\xEF\xBF\xBD\nf>" (s "<\\uD834\\nf>");
+  ()
+
+let decoder_strings () =
+  log "Decoder strings.\n";
+  test_seq Jsonm.decode "\"\"" [`Lexeme (`String "")];
+  test_seq Jsonm.decode "\"heyho\"" [`Lexeme (`String "heyho")];
+  test_seq Jsonm.decode "[\"blibla\"]" (arr [ `Lexeme (`String "blibla") ]);
+  test_seq Jsonm.decode "[\"bli\nbla\"]"
+    (arr [`Error (`Illegal_string_uchar (Uchar.of_int 0x0A));
+          `Lexeme (`String "bli\xEF\xBF\xBDbla"); ]);
+  test_seq Jsonm.decode "[\"blabla"
+    [`Lexeme `As; `Error (`Unclosed `Comment); `End; `End];
+  ()
+
+let decoder_literals () =
+  log "Decoder literals.\n";
+  test_seq Jsonm.decode "null" [`Lexeme `Null];
+  test_seq Jsonm.decode "true" [`Lexeme (`Bool true)];
+  test_seq Jsonm.decode "false" [`Lexeme (`Bool false)];
+  test_seq Jsonm.decode "[null]" (arr [ `Lexeme `Null]);
+  test_seq Jsonm.decode "[true]" (arr [ `Lexeme (`Bool true)]);
+  test_seq Jsonm.decode "[false]" (arr [ `Lexeme (`Bool false)]);
+  test_seq Jsonm.decode "[truee]" (arr [ `Error (`Illegal_literal "truee")]);
+  test_seq Jsonm.decode "[tru"
+    [ `Lexeme `As; `Error (`Illegal_literal "tru"); `Error (`Unclosed `As);
+      `End; `End; `End ];
+  test_seq Jsonm.decode "{\"\" : tru"
+    [ `Lexeme `Os; `Lexeme (`Name ""); `Error (`Illegal_literal "tru");
+      `Error (`Unclosed `Os); `End; `End; `End ];
+  ()
+
+let decoder_numbers () =
+  log "Decoder numbers.\n";
+  test_seq Jsonm.decode "1.0" [`Lexeme (`Float 1.0)];
+  test_seq Jsonm.decode "-1.0" [`Lexeme (`Float ~-.1.0)];
+  test_seq Jsonm.decode "[1.0]" (arr [ `Lexeme (`Float 1.0)]);
+  test_seq Jsonm.decode "[1e12]" (arr [ `Lexeme (`Float 1e12)]);
+  test_seq Jsonm.decode "[-1e12]" (arr [ `Lexeme (`Float ~-.1e12)]);
+  test_seq Jsonm.decode "[-1eee2]" (arr [ `Error (`Illegal_number "-1eee2")]);
+  test_seq Jsonm.decode "[-1ee2"
+    [ `Lexeme `As; `Error (`Illegal_number "-1ee2"); `Error (`Unclosed `As);
+      `End; `End; `End ];
+  test_seq Jsonm.decode "{\"\" : -1ee2"
+    [ `Lexeme `Os; `Lexeme (`Name ""); `Error (`Illegal_number "-1ee2");
+      `Error (`Unclosed `Os); `End; `End; `End ];
+  ()
+
+let decoder_arrays () =
+  log "Decoder arrays.\n";
+  test_seq Jsonm.decode "[]" (arr []);
+  test_seq Jsonm.decode "["
+    [`Lexeme `As; `Error (`Unclosed `As); `End; `End; `End];
+  test_seq Jsonm.decode "[null"
+    [`Lexeme `As; `Lexeme `Null; `Error (`Unclosed `As);
+     `End; `End; `End];
+  test_seq Jsonm.decode "[null,"
+    [`Lexeme `As; `Lexeme `Null; `Error (`Expected (`Value));
+     `Error (`Unclosed `As); `End; `End; `End];
+  test_seq Jsonm.decode "[null { null]"
+    [`Lexeme `As; `Lexeme `Null; `Error (`Expected (`Aval false));
+     `Lexeme `Ae; `End; `End; `End];
+  test_seq Jsonm.decode "[null { null,null]"
+    [`Lexeme `As; `Lexeme `Null; `Error (`Expected (`Aval false));
+     `Lexeme `Null; `Lexeme `Ae; `End; `End; `End];
+  test_seq Jsonm.decode "[; null]"
+    [`Lexeme `As; `Error (`Expected (`Aval true));
+     `Lexeme `Ae; `End; `End; `End];
+  test_seq Jsonm.decode "[; , null]"
+    [`Lexeme `As; `Error (`Expected (`Aval true)); `Lexeme `Null;
+     `Lexeme `Ae; `End; `End; `End];
+  ()
+
+let decoder_objects () =
+  log "Decoder objects.\n";
+  test_seq Jsonm.decode "{"
+    [`Lexeme `Os; `Error (`Unclosed `Os); `End; `End; `End];
+  test_seq Jsonm.decode "{null"
+    [`Lexeme `Os; `Error (`Expected (`Omem true)); `Error (`Unclosed `Os);
+     `End; `End; `End];
+  test_seq Jsonm.decode "{ \"b\" "
+    [`Lexeme `Os; `Lexeme (`Name "b"); `Error (`Expected (`Name_sep));
+     `Error (`Unclosed `Os); `End; `End; `End];
+  test_seq Jsonm.decode "{ \"b\" : ] null]"
+    [`Lexeme `Os; `Lexeme (`Name "b"); `Error (`Expected (`Value));
+     `Error (`Unclosed `Os); `End; `End; `End];
+  test_seq Jsonm.decode "{ \"b\" : null"
+    [`Lexeme `Os; `Lexeme (`Name "b"); `Lexeme `Null;
+     `Error (`Unclosed `Os); `End; `End; `End];
+  test_seq Jsonm.decode "{; null}"
+    [`Lexeme `Os; `Error (`Expected (`Omem true));
+     `Lexeme `Oe; `End; `End; `End];
+  test_seq Jsonm.decode "{ ill : null, \"bli\" : null}"
+    [`Lexeme `Os; `Error (`Expected (`Omem true)); `Lexeme (`Name "bli");
+     `Lexeme `Null; `Lexeme `Oe; `End; `End; `End];
+  test_seq Jsonm.decode "{ \"bli\" : null ill : null }"
+    [`Lexeme `Os; `Lexeme (`Name "bli");
+     `Lexeme `Null; `Error (`Expected (`Omem false));
+     `Lexeme `Oe; `End; `End; `End];
+  test_seq Jsonm.decode "{ \"bli\" : null, ill : null }"
+    [`Lexeme `Os; `Lexeme (`Name "bli");
+     `Lexeme `Null; `Error (`Expected `Name);
+     `Lexeme `Oe; `End; `End; `End];
+  ()
+
+let decoder_json_text () =
+  log "Decoder JSON text.\n";
+  test_seq Jsonm.decode "a" [ `Error (`Expected `Json);
+                              `Error (`Expected `Json); `End ];
+  test_seq Jsonm.decode "" [ `Error (`Expected `Json); `End ];
+  test_seq Jsonm.decode "a : null {}"
+    [ `Error (`Expected `Json);
+      `Error (`Expected `Json);
+      `Lexeme `Null;
+      `Error (`Expected `Eoi); `End];
+  test_seq Jsonm.decode "a : null []"
+    [ `Error (`Expected `Json);
+      `Error (`Expected `Json);
+      `Lexeme `Null;
+      `Error (`Expected `Eoi); `End];
+  ()
+
+let decoder_bom () =
+  log "Decoder BOM.\n";
+  let seq = [`Error `Illegal_BOM; `Lexeme `Os; `Lexeme `Oe; `End] in
+  test_seq Jsonm.decode "\xEF\xBB\xBF  {}" seq;
+  test_seq Jsonm.decode "\xFE\xFF\x00\x7B\x00\x7D" seq;
+  test_seq Jsonm.decode "\xFF\xFE\x7B\x00\x7D\x00" seq;
+  ()
+
+
+let decoder_eoi () =
+  log "Decoder end of input.\n";
+  test_seq Jsonm.decode "" [`Error (`Expected `Json) ];
+  test_seq Jsonm.decode "{} a : null"
+    [ `Lexeme `Os; `Lexeme `Oe; `Error (`Expected `Eoi); ];
+  test_seq Jsonm.decode "[] a : null "
+    [ `Lexeme `As; `Lexeme `Ae; `Error (`Expected `Eoi); ];
+  ()
+
+let trip () =
+  log "Codec round-trips.\n";
+  let trip s =
+    let b = Buffer.create (String.length s) in
+    let d = Jsonm.decoder (`String s) in
+    let e = Jsonm.encoder (`Buffer b) in
+    let rec loop d e = match Jsonm.decode d with
+    | `Lexeme _ as v -> ignore (Jsonm.encode e v); loop d e
+    | `End as v -> ignore (Jsonm.encode e v)
+    | `Error e -> fail "err: %a" Jsonm.pp_error e
+    | `Await -> assert false
+    in
+    loop d e;
+    let trips = Buffer.contents b in
+    if trips <> s then
+    fail "fnd: %s@\nexp: %s@\n" trips s
+  in
+  trip "null";
+  trip "true";
+  trip "false";
+  trip "2";
+  trip "0.5";
+  trip "\"heyho\"";
+  trip "[null,null,0.5,true,false,[true,false]]";
+  trip "{\"a\":[1,2,4,5,[true,false]],\"b\":{}}";
+  trip "{\"a\":[1,2,4,5,[true,{\"c\":[null]}]],\"b\":{}}";
+  trip "{\"a\":[1,2,4,5,[true,{\"c\":[\"\\nbli\",5,6]}]],\"b\":{}}";
+  (* Verify that integers that can be represented exactly by an OCaml float
+     value [-2^53;2^53] do trip. *)
+  trip "[9007199254740992,-9007199254740992]";
+  ()
+
+let test () =
+  Printexc.record_backtrace true;
+  encoder_invalid ();
+  encoder_escapes ();
+  decoder_encoding_guess ();
+  decoder_escapes ();
+  decoder_comments ();
+  decoder_literals ();
+  decoder_numbers ();
+  decoder_arrays ();
+  decoder_objects ();
+  decoder_json_text ();
+  decoder_bom ();
+  decoder_eoi ();
+  trip ();
+  log "All tests succeeded.\n"
+
+let () = if not (!Sys.interactive) then test ()
+
+(*---------------------------------------------------------------------------
+   Copyright (c) 2012 The jsonm programmers
+
+   Permission to use, copy, modify, and/or distribute this software for any
+   purpose with or without fee is hereby granted, provided that the above
+   copyright notice and this permission notice appear in all copies.
+
+   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  ---------------------------------------------------------------------------*)
